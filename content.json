{"pages":[],"posts":[{"title":"Burp suite 分析 HTTP协议","text":"# Burp suite 分析 HTTP 协议 1. 实验环境 1.manjaro-gnome-20.1.2 2.Burp suite-Community-v2020.11.1(下载地址) 2.Burp suite 安装与配置 打开 Firefox，安装下图插件。 配置代理，端口号可自行选择 (选择空闲的就可)。 配置 Burp suite，端口要与前面的配置一致。 访问 http://burp/ 下载 burpsuite ca 证书 需开启刚刚配置的代理 点击右上角 CA Certificate 点击首选项 &gt;&gt; 隐私与安全 &gt;&gt; 查看证书 导入刚刚下载的证书 3. 分析 HTTP 开启拦截，在 Firefox 输入 https://www.baidu.com 至此，你就可以拦截请求与响应开始装逼了 (请参照附录分析)。 HTTP 状态码 所有 HTTP 响应的第一行都是状态行，依次是当前 HTTP 版本号，3 位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。 状态代码的第一个数字代表当前响应的类型： 1xx 消息 —— 请求已被服务器接收，继续处理 2xx 成功 —— 请求已成功被服务器接收、理解、并接受 3xx 重定向 —— 需要后续操作才能完成这一请求 4xx 请求错误 —— 请求含有词法错误或者无法被执行 5xx 服务器错误 —— 服务器在处理某个正确请求时发生错误 HTTP 请求方法 请读者自行学习 GET 与 POST (重点哦) GET POST HEAD PUT DELETE TRACE OPTIONS CONNECT # 附录 请求字段 响应字段 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/Burp%20suite%20%E5%88%86%E6%9E%90%20HTTP%E5%8D%8F%E8%AE%AE/"},{"title":"C# 读写json文件","text":"# C# 读写 json 文件 实验环境：VS2017（宇宙最最屌 IDE） 1. 安装 Newtonsoft.Json 12在控制台输入，回车。Install-Package Newtonsoft.Json 然后在所需的项目添加引用。 找到安装目录选择相应版本。 2. 新建一个 config.json 文件。(名字各位大爷随意) 12345{ &quot;server&quot;: &quot;.&quot;, &quot;user&quot;: &quot;sa&quot;, &quot;passwd&quot;: &quot;n123456&quot;} 3.Read 123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Configuration;//记得引用这几个玩意using Newtonsoft.Json;using Newtonsoft.Json.Linq;using System.IO;namespace 操作json与xml{ class ReadJson { public static string Get_server() { try { StreamReader reader = File.OpenText(&quot;config.json&quot;); JsonTextReader jsonTextReader = new JsonTextReader(reader); JObject jsonObject = (JObject)JToken.ReadFrom(jsonTextReader); string server = jsonObject[&quot;server&quot;].ToString(); //user ,passwd 类似 reader.Close(); return server; } catch { //自己加点 } } }} 4.Write 123456789101112131415161718public static void Set_server(string server) { try { StreamReader reader = File.OpenText(&quot;config.json&quot;); JsonTextReader jsonTextReader = new JsonTextReader(reader); JObject jsonObject = (JObject)JToken.ReadFrom(jsonTextReader); jsonObject[&quot;server&quot;] = server; //user ,passwd 类似 reader.Close(); string output = Newtonsoft.Json.JsonConvert.SerializeObject(jsonObject, Newtonsoft.Json.Formatting.Indented); File.WriteAllText(&quot;config.json&quot;, output); } catch { //自己加点 } } 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/C#%E8%AF%BB%E5%86%99json%E6%96%87%E4%BB%B6%E2%80%94%E2%80%94Newtonsoft/"},{"title":"C语言程序里全局变量、局部变量、堆、栈","text":"# C 语言程序里全局变量、局部变量、堆、栈 1. 实验环境 1.ubuntu20 全局变量、静态局部变量保存在全局数据区，初始化的和未初始化的分别保存在一起。普通局部变量保存在堆栈中。 在 C\\C++ 中，通常可以把内存理解为 4 个分区：栈、堆、全局 / 静态存储区和常量存储区 1. 内存栈区 stack： 存放局部变量名； 2. 内存堆区 heap： 存放 new 或者 malloc 出来的对象； 3.Text &amp; Data &amp; Bss：代码段与静态分配 4.BSS 区（未初始化数据段）：并不给该段的数据分配空间，仅仅是记录了数据所需空间的大小。 5.DATA（初始化的数据段）：为数据分配空间，数据保存在目标文件中。 2. 源码 haha.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void before(){}char g_buf[16];char g_buf2[16];char g_buf3[16];char g_buf4[16];char g_i_buf[]=&quot;123&quot;;char g_i_buf2[]=&quot;123&quot;;char g_i_buf3[]=&quot;123&quot;;void after(){}int main(int argc, char **argv){ char l_buf[16]; char l_buf2[16]; char l_buf3[16]; static char s_buf[16]; static char s_buf2[16]; static char s_buf3[16]; char *p_buf; char *p_buf2; char *p_buf3; p_buf = (char *)malloc(sizeof(char) * 16); p_buf2 = (char *)malloc(sizeof(char) * 16); p_buf3 = (char *)malloc(sizeof(char) * 16); printf(&quot;g_buf: 0x%x\\n&quot;, g_buf); printf(&quot;g_buf2: 0x%x\\n&quot;, g_buf2); printf(&quot;g_buf3: 0x%x\\n&quot;, g_buf3); printf(&quot;g_buf4: 0x%x\\n&quot;, g_buf4); printf(&quot;g_i_buf: 0x%x\\n&quot;, g_i_buf); printf(&quot;g_i_buf2: 0x%x\\n&quot;, g_i_buf2); printf(&quot;g_i_buf3: 0x%x\\n&quot;, g_i_buf3); printf(&quot;l_buf: 0x%x\\n&quot;, l_buf); printf(&quot;l_buf2: 0x%x\\n&quot;, l_buf2); printf(&quot;l_buf3: 0x%x\\n&quot;, l_buf3); printf(&quot;s_buf: 0x%x\\n&quot;, s_buf); printf(&quot;s_buf2: 0x%x\\n&quot;, s_buf2); printf(&quot;s_buf3: 0x%x\\n&quot;, s_buf3); printf(&quot;p_buf: 0x%x\\n&quot;, p_buf); printf(&quot;p_buf2: 0x%x\\n&quot;, p_buf2); printf(&quot;p_buf3: 0x%x\\n&quot;, p_buf3); printf(&quot;before: 0x%x\\n&quot;, before); printf(&quot;after: 0x%x\\n&quot;, after); printf(&quot;main: 0x%x\\n&quot;, main); if (argc &gt; 1) { strcpy(l_buf, argv[1]); } return 0;} 3. 效果 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E9%87%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%A0%86%E3%80%81%E6%A0%88/"},{"title":"ubuntu安装教程","text":"# ubuntu 安装教程 1. 实验环境 1.ubuntu16.04(安装教程) 2.jdk-14.0.1(下载地址) 我下载的是这个 2. 解压 将 jdk 下载到 /usr/local/java 1234cd /usr/localmkdir javacd javatar -zxvf jdk-14.0.1_linux-x64_bin.tar.gz 解压后会出现一个 jdk-14.0.1 文件夹。 3. 配置 JDK 环境变量 vim /etc/profile 加入以下内容 1234JAVA_HOME=/usr/local/java/jdk-14.0.1CLASSPATH=$JAVA_HOME/lib/PATH=$PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH 刷新一下 1source /etc/profile 验证一下 1java -version nice，安装成功！！！！ # windows 1. 实验环境 1.win10 2.jdk-14.0.1(下载地址) 由于是图形化安装，就不写详细过程了，注意记住安装路径。 2. 配置环境 右键此电脑，点击属性。 点击高级系统设置 点击环境变量 JAVA_HOME（值填写 jdk 安装路径） CLASSPATH 1.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 在 PATH 里添加 12%JAVA_HOME%\\bin%JAVA_HOME%\\jre\\bin 一路保存 3. 验证 1java -version nice，成功了！！！！！！ 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/JDK%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/"},{"title":"Ubuntu Centos静态ip设置","text":"# Ubuntu Centos 静态 ip 设置 1. 实验环境 1.VMware16.0.0 2.Ubuntu16.04(安装教程) 3.Centos8 4.VMware 网络模式：NAT 2. 配置 VMnet8 打开 PowerShell，执行命令，查看虚拟网卡是否安装。 1ipconfig VMnet8 用于 NAT 模式。 若无上图两块虚拟网卡，请打开 VMware，虚拟网络编辑器，还原默认设置。（需要管理员权限）若有上图虚拟网卡，自行跳过这一步。 打开控制面板，右击 VMnet8 属性。 点击属性 配置 IP 地址你也可以自定义。 比如 IP 地址你定义为 192.168.146.1，那么你的网关的前 3 段要一样 192.168.146 你可以翻阅一下有关子网掩码、网络地址和主机地址等知识 接下来开始配置 VMware。因为需要配置静态 ip，所以要将本地 DHCP 服务给取消了。配置子网 IP，子网掩码。 填写网关，要与前面的配置一致 一路保存。开启 ubuntu，centOS 开始配置。 3.ubuntu 配置 执行命令，查看网络信息。 1ifconfig 我们需要给 ens33 配置一个静态 ip，执行命令，开始配置。 1vim /etc/network/interfaces 配置内容如下 iface ens33 inet static 静态 ip（static，原来是 dhcp） address ip 地址 netmask 子网掩码 gateway 网关 1234567891011121314# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopbackauto ens33iface ens33 inet staticaddress 192.168.146.104netmask 255.255.255.0gateway 192.168.146.2 保存。 执行命令，配置 DNS 服务器 1vim /etc/resolvconf/resolv.conf.d/base 保存。 重启一下机子就好 1reboot 成功。 4.CentOS 配置 执行命令，查看网络 1ifconfig 需要配置 ens33。 执行命令，开始配置。 1vim /etc/sysconfig/network-scripts/ifcfg-ens33 填写以下内容 BOOTPROTO 填 static IPADDR 填你要设定的 IP GATEWAY 填写网关 NETMASK 填写子网掩码 DNS1 填写 DNS 服务器地址，填网关就好 ONBOOT 填 yes 1234567891011121314151617181920TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticDEFROUTE=yesIPADDR=192.168.146.129GATEWAY=192.168.146.2NETMASK=255.255.255.0DNS1=192.168.146.2IPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=152a6305-70b6-4b63-b7b9-6b9c52c0c752DEVICE=ens33ONBOOT=yes 执行命令，配置 resolv.conf，填写你的网关就好。 1vim /etc/resolv.conf 重启机子 1reboot 今天的文章就肝到这里了。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/Ubuntu%20Centos%E9%9D%99%E6%80%81ip%E8%AE%BE%E7%BD%AE/"},{"title":"php 连接sql server数据库","text":"# php 连接 sql server 数据库 折腾了一天，终于把该死的数据库连起了，现在我就将我遇到的问题与配置的一些过程记录一下，希望有所帮助。 1. 环境 1.phpstudy 2.VS Code 3.php7.3.4nts 注意： nts&gt;&gt; 线程不安全 ts&gt;&gt; 线程安全 2. 下载与配置 连接 sql server 需要下载点东西 1 下载 SQLSRV58.EXE 这玩意不需要安装，解压后就是这么一堆东西： 上述玩意要根据自己的环境选择，请接着看。 在自己的本地站下放一个 php 脚本看一哈信息。(用 phpstudy 搭个站) 123&lt;?phpecho phpinfo();?&gt; 这是我的环境。 所以我的 sqlsrv，就得选 7.3，nts，x64 注意：选择自己相应版本，如果 sqlsrv58 里没有，就去下载别的版本 sqlsrv。 把这两个玩意拷贝到对应 php 版本文件夹下。 然后在 php.ini 添加以下 123extension=php_sqlsrv_73_nts_x64extension=php_pdo_sqlsrv_73_nts_x64 3. 连接测试 1. 重启 apache 1234567891011121314151617&lt;?php $serverName = &quot;.&quot;; //数据库服务器地址$uid = &quot;sa&quot;; //数据库用户名$pwd = &quot;123456&quot;; //数据库密码$connectionInfo = array(&quot;UID&quot;=&gt;$uid, &quot;PWD&quot;=&gt;$pwd, &quot;Database&quot;=&gt;&quot;phpTest&quot;);$conn = sqlsrv_connect($serverName, $connectionInfo);if( $conn == false){ echo &quot;连接失败！&quot;; var_dump(sqlsrv_errors()); exit;}else{ echo &quot;链接成功&quot;;}?&gt; OK，成功了。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/VS%20Code%20%E7%94%A8php%20%E8%BF%9E%E6%8E%A5sql%20server%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"VS code php 如何调试","text":"# VS code php 如何调试 今天来写一篇如何调试 ” 拍黄片 “ 的 blog。 废话不说了，直接干。 开发环境： 1.VS code 2.phpstudy 1. 配置一哈 VS code (为了开发体验好一点，需要装几个插件哦) 1.PHP Intelephense 2.PHP Debug 2. 安装 XDebug（phpstudy 貌似集成了这玩意） 1. 在 php.ini 加入下面三行代码 (路径填自己的) 2. 保存， 3. 重启 apache 服务。 123xdebug.remote_enable = 1xdebug.remote_autostart = 1zend_extension=&quot;F:\\PHPstudy\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\ext\\php_xdebug.dll&quot; 3. 配置 launch.json 信息 端口用默认 9000 就好 4. 用个小例子试试。 123456&lt;?php $a = 1; $b = 2; $c = $a + $b; echo $c;?&gt; 1… 2. 添加断点 3. 开启调试 4. 刷新一下浏览器 看到下图，恭喜恭喜，成功喽 @@@@ 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/VS%20code%20php%20%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95/"},{"title":"ensp仿真","text":"# ensp 仿真 1. 实验环境 1.ensp-1.2.00.510 2.vmware16 3.win7 虚拟机 VirtualBox-5.2.44 2. 实验 1 目的 通过路由器打通两台处于不同子网主机的链路。 2 台 PC 路由器：2 台 AR2220 网络拓扑 R1 配置 12345678910111213141516# 配置g0/0/1 ipsysint g0/0/1ip add 192.168.0.254 24# 配置g0/0/0 ipint g0/0/0ip add 192.168.1.1# 添加静态路由qip route-static 192.168.2.0 24 g0/0/0 192.168.1.2# 查看静态路由表dis ip routing-table R2 配置 12345678910111213141516# 配置g0/0/1 ipsysint g0/0/1ip add 192.168.2.254 24# 配置g0/0/0 ipint g0/0/0ip add 192.168.1.2# 添加静态路由qip route-static 192.168.0.0 24 g0/0/0 192.168.1.1# 查看静态路由表dis ip routing-table PC1 PC2 试验 2 目的 配置 vlan 4 台 PC 2 台 S3700 网络拓扑 PC1 配置 PC2 配置 PC3 配置 PC4 配置 LSW1 配置 123456789101112131415161718# 创建vlan 1 2vlan batch 1 2# 配置e0/0/1int e0/0/1port link-type trunkport trunk allow-pass vlan 1 2# 配置e0/0/2int e0/0/2port link-type accessport default vlan 1# 配置e0/0/3int e0/0/3port link-type accessport default vlan 2 LSW2 配置 1234567891011121314151617# 创建vlan 1 2vlan batch 1 2# 配置e0/0/1int e0/0/1port link-type trunkport trunk allow-pass vlan 1 2# 配置e0/0/2int e0/0/2port link-type accessport default vlan 1# 配置e0/0/3int e0/0/3port link-type accessport default vlan 2 实验 3 目的 配置 ospf 打通处于不同网络主机的网络链路 2 台 PC 3 台 AR2220 网络拓扑 PC1 配置 PC2 配置 AR1 配置 123456789101112131415161718# 配置g0/0/0/1 ipsysint g0/0/1ip add 192.168.0.254 24# 配置g0/0/0/0 ipint g0/0/0ip add 1.1.1.1 24# 配置ospf# 1为ospf进程ip,可以与其它路由器相同，1.1.1.1为router-id，是路由器唯一标识，不可相同。# network 为区域下宣告ospf 1 router-id 1.1.1.1area 0network 1.1.1.1 0.0.0.0network 192.168.0.254 0.0.0.0 AR2 配置 1234567891011121314151617# 配置g0/0/0/1 ipsysint g0/0/1ip add 2.2.2.1 24# 配置g0/0/0/0 ipint g0/0/0ip add 1.1.1.2 24# 配置ospf# 1为ospf进程ip,可以与其它路由器相同，2.2.2.2为router-id，是路由器唯一标识，不可相同。# network 为区域下宣告ospf 1 router-id 2.2.2.2area 0network 1.1.1.2 0.0.0.0network 2.2.2.1 0.0.0.0 AR3 配置 1234567891011121314151617# 配置g0/0/0/1 ipsysint g0/0/1ip add 192.168.1.254 24# 配置g0/0/0/0 ipint g0/0/0ip add 2.2.2.2 24# 配置ospf# 1为ospf进程ip,可以与其它路由器相同，3.3.3.3为router-id，是路由器唯一标识，不可相同。# network 为区域下宣告ospf 1 router-id 3.3.3.3area 0network 192.168.1.254 0.0.0.0network 2.2.2.2 0.0.0.0 实验 4 目的： 配置三层交换 5 台 PC 2 台 S3700 (LSW1 LSW2) 1 台 S5700 (LSW3) 2 台 AR2220 网络拓扑 PC1 配置 PC2 配置 PC3 配置 PC4 配置 PC5 配置 LSW1 配置 123456789101112131415161718192021222324# 创建vlansysvlan batch 2 3# 配置e0/0/1int e0/0/1port link-type trunkport trunk allow-pass vlan all# 配置e0/0/2int e0/0/2port link-type trunkport trunk allow-pass vlan all# 配置e0/0/3int e0/0/3port link-type accessport default vlan 1# 配置e0/0/4int e0/0/4port link-type accessport default vlan 2 LSW2 配置 1234567891011121314151617181920212223# 创建vlansysvlan batch 2 3# 配置e0/0/1int e0/0/1port link-type trunkport trunk allow-pass vlan all# 配置e0/0/2int e0/0/2port link-type trunkport trunk allow-pass vlan all# 配置e0/0/3int e0/0/3port link-type accessport default vlan 1# 配置e0/0/4int e0/0/4port link-type accessport default vlan 2 LSW3 配置 1234567891011121314151617181920212223242526272829# 创建vlansysvlan batch 2 3# 配置g0/0/1int g0/0/1port link-type trunkport trunk allow-pass vlan all# 配置g0/0/2int g0/0/2port link-type trunkport trunk allow-pass vlan all# 配置vlan ipint vlanif 1ip add 192.168.2.254 24int vlanif 2ip add 192.168.0.254 24int vlanif 3ip add 192.168.1.254 24# 配置ospfospf 1 router-id 3.3.3.3area 0net 192.168.0.254 0.0.0.0net 192.168.1.254 0.0.0.0net 192.168.2.254 0.0.0.0 AR1 配置 1234567891011121314# 配置g0/0/0sysint g0/0/0ip add 192.168.2.3 24# 配置g0/0/1int g0/0/1ip add 1.1.1.1 24# 配置ospfospf 1 router-id 1.1.1.1area 0net 192.168.2.3 0.0.0.0net 1.1.1.1 0.0.0.0 AR2 配置 1234567891011121314# 配置g0/0/0sysint g0/0/0ip add 1.1.1.2 24# 配置g0/0/1int g0/0/1ip add 2.2.2.1 24# 配置ospfospf 1 router-id 2.2.2.2area 0net 1.1.1.2 0.0.0.0net 2.2.2.1 0.0.0.0","link":"/2021/05/08/ensp%E4%BB%BF%E7%9C%9F/"},{"title":"java处理json文件——gson","text":"# java 处理 json 文件 ——gson 1. 实验环境 1.manjaro-21 2.JDK1.8.0-281 3.gson-2.8.6 项目地址 在 Gradle/Android 中使用 123dependencies { implementation 'com.google.code.gson:gson:2.8.6'} 在 Maven 中使用 123456789&lt;dependencies&gt; &lt;!-- Gson: Java to Json conversion --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. 将一个对象转为 json 字符串 MyJson.java 1234567891011121314151617181920212223242526272829public class MyJson { private String name; private int age; private String email; public MyJson() { } public MyJson(String name,int age,String email) { this.name = name; this.age = age; this.email = email; } public String getName() { return name; } public int getAge() { return age; } public String getEmail() { return email; }} Application.java 12345678910import com.google.gson.Gson;public class Application { public static void main(String[] args) { MyJson myJson = new MyJson(&quot;Tom&quot;,15,&quot;haha@jiji.com&quot;); Gson gson = new Gson(); String json = gson.toJson(myJson); System.out.println(json); }} 输出结果 1{&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:15,&quot;email&quot;:&quot;haha@jiji.com&quot;} 3. 将 json 字符串解析为 java 对象 Application.java 12345678910111213import com.google.gson.Gson;public class Application { public static void main(String[] args) { MyJson myJson = new MyJson(); Gson gson = new Gson(); String text = &quot;{\\&quot;name\\&quot;:\\&quot;Tom\\&quot;,\\&quot;age\\&quot;:19,\\&quot;email\\&quot;:\\&quot;hello@jiba.com\\&quot;}&quot;; myJson = gson.fromJson(text,myJson.getClass()); System.out.println(myJson.getName()); System.out.println(myJson.getAge()); System.out.println(myJson.getEmail()); }} 输出结果 123Tom19hello@jiba.com 4. 将 ArrayList 转为 json 数组 Application.java 123456789101112import com.google.gson.Gson;public class Application { public static void main(String[] args) { Gson gson = new Gson(); ArrayList&lt;MyJson&gt; list = new ArrayList&lt;&gt;(); list.add(new MyJson(&quot;name1&quot;,10,&quot;ki@jiba.com&quot;)); list.add(new MyJson(&quot;name2&quot;,19,&quot;hi@jiba.com&quot;)); String json = gson.toJson(list); System.out.println(json); }} 输出结果 1[{&quot;name&quot;:&quot;name1&quot;,&quot;age&quot;:10,&quot;email&quot;:&quot;ki@jiba.com&quot;},{&quot;name&quot;:&quot;name2&quot;,&quot;age&quot;:19,&quot;email&quot;:&quot;hi@jiba.com&quot;}] 5. 将 json 数组转为 ArrayList Application.java 123456789101112131415161718import com.google.gson.Gson;public class Application { public static void main(String[] args) { Gson gson = new Gson(); ArrayList&lt;MyJson&gt; list = new ArrayList&lt;&gt;(); Type listType = new TypeToken&lt;List&lt;MyJson&gt;&gt;(){}.getType(); String text = &quot;[{\\&quot;name\\&quot;:\\&quot;name1\\&quot;,\\&quot;age\\&quot;:10,\\&quot;email\\&quot;:\\&quot;ki@jiba.com\\&quot;},{\\&quot;name\\&quot;:\\&quot;name2\\&quot;,\\&quot;age\\&quot;:19,\\&quot;email\\&quot;:\\&quot;hi@jiba.com\\&quot;}]&quot;; list = gson.fromJson(text,listType); for (MyJson obj : list) { System.out.println(obj.getName()); System.out.println(obj.getAge()); System.out.println(obj.getEmail()); } }} 输出结果 123456name110ki@jiba.comname219hi@jiba.com 6. 从文件流读取 json 数据转换为 java 对象 myJson.json 1234567891011121314[ { &quot;name&quot;: &quot;name1&quot;, &quot;age&quot;: 10, &quot;email&quot;: &quot;ki@jiba.com&quot; }, { &quot;name&quot;: &quot;name2&quot;, &quot;age&quot;: 19, &quot;email&quot;: &quot;hi@jiba.com&quot; }] Application.java 123456789101112131415public class Application { public static void main(String[] args) throws IOException { ArrayList&lt;MyJson&gt; list = new ArrayList&lt;&gt;(); Type listType = new TypeToken&lt;List&lt;MyJson&gt;&gt;(){}.getType(); Gson gson = new Gson(); File file = new File(&quot;/home/hello/myCode/java/json/gson/src/main/java/xyz/wuhen/gson/myJson.json&quot;); FileReader reader = new FileReader(file); list = gson.fromJson(reader,listType); for (MyJson obj : list) { System.out.println(obj.getName()); System.out.println(obj.getAge()); System.out.println(obj.getEmail()); } }} 输出结果 123456name110ki@jiba.comname219hi@jiba.com 7. 从 URL 读取 json 数据字节流转为 java 对象 Application.java 123456789101112131415public class Application { public static void main(String[] args) throws IOException { ArrayList&lt;MyJson&gt; list = new ArrayList&lt;&gt;(); Type listType = new TypeToken&lt;List&lt;MyJson&gt;&gt;(){}.getType(); Gson gson = new Gson(); URL url = new URL(&quot;http://127.0.0.1/myJson.json&quot;); JsonReader reader = new JsonReader(new InputStreamReader(url.openStream())); list = gson.fromJson(reader,listType); for (MyJson obj : list) { System.out.println(obj.getName()); System.out.println(obj.getAge()); System.out.println(obj.getEmail()); } }} 输出结果 123456name110ki@jiba.comname219hi@jiba.com 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/java%E5%A4%84%E7%90%86json%E6%96%87%E4%BB%B6%E2%80%94%E2%80%94gson/"},{"title":"java解析html文件——Jsoup","text":"# java 解析 html 文件 ——Jsoup 1. 实验环境 1.manjaro-gonme21 2.Jsoup-1.13.1 项目地址 3.JDK-1.8.0_281 Maven 使用 Jsoup 12345&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.13.1&lt;/version&gt;&lt;/dependency&gt; Gradle 使用 Jsoup 1implementation 'org.jsoup:jsoup:1.13.1' 2. 从 String 解析 html 将 String 解析为 Document 对象 Application.java 123456789101112131415public class Application { public static void main(String[] args) throws IOException { String html = &quot;&lt;html&gt;\\n&quot; + &quot;&lt;head&gt;\\n&quot; + &quot;&lt;title&gt;Try jsoup&lt;/title&gt;\\n&quot; + &quot;&lt;/head&gt;\\n&quot; + &quot;&lt;body&gt;\\n&quot; + &quot;&lt;p&gt;This is &lt;a href=\\&quot;http://jsoup.org/\\&quot;&gt;jsoup&lt;/a&gt;.&lt;/p&gt;\\n&quot; + &quot;&lt;/body&gt;\\n&quot; + &quot;&lt;/html&gt;&quot;; Document document = Jsoup.parse(html); System.out.println(document); }} 输出结果 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Try jsoup&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is &lt;a href=&quot;http://jsoup.org/&quot;&gt;jsoup&lt;/a&gt;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 3. 从文件流解析 html 将 String 解析为 Document 对象 myHtml.html 12345678&lt;html&gt;&lt;head&gt; &lt;title&gt;Try jsoup&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is &lt;a href=&quot;http://jsoup.org/&quot;&gt;jsoup&lt;/a&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Application.java 1234567public class Application { public static void main(String[] args) throws IOException { Document document = Jsoup.parse(new File(&quot;/home/hello/myCode/java/html/Jsoup/src/main/java/xyz/wuhen/Jsoup/myHtml.html&quot;),&quot;utf-8&quot;); System.out.println(document); }} 输出结果 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Try jsoup&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is &lt;a href=&quot;http://jsoup.org/&quot;&gt;jsoup&lt;/a&gt;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 4. 从网络数据流解析 html 将网络数据流转为 Document 对象 Application.java 1234567public class Application { public static void main(String[] args) throws IOException { Document document = Jsoup.connect(&quot;http://127.0.0.1/myHtml.html&quot;).get(); System.out.println(document); }} 输出结果 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Try jsoup&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is &lt;a href=&quot;http://jsoup.org/&quot;&gt;jsoup&lt;/a&gt;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/java%E8%A7%A3%E6%9E%90html%E6%96%87%E4%BB%B6%E2%80%94%E2%80%94Jsoup/"},{"title":"linux gdb 调试c代码小例一则","text":"# linux gdb 调试 c 代码小例一则 1. 实验环境 1.ubuntu20 2.gdb-9.2 3.gcc-9.3.0 2. 代码 main.c 12345678910111213141516171819/************************************************************************* &gt; File Name: main.c &gt; Author: wuhen &gt; Created Time: Thu 29 Oct 2020 04:52:54 PM CST ************************************************************************/#include&lt;stdio.h&gt;int main(){ int a = 1; int b = 2; int c; int d; c = a + b; d = a + b + c; printf(&quot;a:%d\\nb:%d\\n&quot;,c,d); return 0;} 3. 调试 执行命令，编译 1gcc -o main.out -g main.c 执行命令，开始调试 1gdb main.out 123start #开始调试n #运行下一行 关于命令详解大家看这个就好 相关文章 python 初试 opencv python 操作摄像头 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/linux%20gdb%20%E8%B0%83%E8%AF%95c%E4%BB%A3%E7%A0%81%E5%B0%8F%E4%BE%8B%E4%B8%80%E5%88%99/"},{"title":"linux初试gcc makefile菜鸟教程","text":"# linux 初试 gcc makefile 菜鸟教程 1. 实验环境 1.ubuntu16(安装教程) 2.gcc (gcc 安装：apt install gcc) 3.make (make 安装 apt install make) 用 C 举个小例子 2. 源码 main.c 1234567891011121314151617181920212223/************************************************************************* &gt; File Name: main.c &gt; Author: wuhen &gt; Mail: wuhen1090@qq.com &gt; Created Time: Fri 25 Sep 2020 09:52:19 PM CST ************************************************************************/#include&lt;stdio.h&gt;int sub(int a,int b);int main(){ int a; int b; float c; printf(&quot;请敲个数 a=&quot;); scanf(&quot;%d&quot;,&amp;a); printf(&quot;请敲个数 b=&quot;); scanf(&quot;%d&quot;,&amp;b); c = sub(a,b); printf(&quot;c=%.1f\\n&quot;,c); return 0;} sub.c 1234567891011/************************************************************************* &gt; File Name: sub.c &gt; Author: wuhen &gt; Mail: wuhen1090@qq.com &gt; Created Time: Fri 25 Sep 2020 09:48:26 PM CST ************************************************************************/float sub(int a,int b){ return a + b;} 编译一下 1gcc -o out main.c sub.c Nice，成功了 3.makefile 当做一个大些的工程时，使用刚才的方式就有些恼火，so，我们可以用神器 ——make 来解决它。 makefile 123456789all:main.o sub.o gcc -o all main.o sub.omain.o:main.c gcc -c main.csub.o:sub.c gcc -c sub.cclean: rm main.o sub.o OK，今天的文章就肝到这里。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/linux%E5%88%9D%E8%AF%95gcc%20makefile%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/"},{"title":"linux如何使用U盘等外接储存设备","text":"# linux 如何使用 U 盘等外接储存设备 1. 插入 U 盘 2. 查看 12lsblk #查看所有块设备 我的是 256MB 的 U 盘，就是如图所示的 sdb 设备了，mountpoint 为空，因为还没有挂载哩。 sdb 对应的路径因该是 /dev/sdb 喽（你可以用 fdisk -l 查看一下） 3. 挂载 123mkdir /mnt/usb #新建一个目录，用来挂载U盘mount /dev/sdb /mnt/usb #把U盘挂载到/mnt/usblsblk #查看一下 sdb 的 mountpoint 不在为空，而是刚才的挂载点 /mnt/usb 恭喜！！！可以在 /mnt/usb 下浏览 U 盘内容了 4.umount 用完后，先执行 12umount /dev/sdb /mnt/usb #先卸载lsblk #查看一下 mountpoint 又变为空了。but 你用 fdisk -l 查看（显示 U 盘还在），这时你需要关闭驱动器。 5. 安全关闭驱动器 12udisksctl power-off -b /dev/sdb #安全关闭驱动器fdisk -l #查看 这下 U 盘没了（弹出了） 注意：如果提示 123The program 'udisksctl' is currently not installed. You can install it by typing:apt install udisks2 安装 udisks2 再试 1apt install udisks2 #安装udisks2 6. 拔掉 U 盘 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/linux%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8U%E7%9B%98%E7%AD%89%E5%A4%96%E6%8E%A5%E5%82%A8%E5%AD%98%E8%AE%BE%E5%A4%87/"},{"title":"安装Maven","text":"安装 Maven 执行命令，切换到 opt 目录 1cd /opt 执行命令，创建 maven 文件夹 1mkdir maven 执行命令，切换到 maven 目录，下载 maven-3.6.3，解压压缩包 1234cd mavenwget http://www.trieuvan.com/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gztar zxvf apache-maven-3.6.3-bin.tar.gz 换源 (在标签中添加 mirror 子节点：)，提升下载速度。(这里用阿里源) 1vim apache-maven-3.6.3/conf/settings.xml 12345678&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; 配置环境变量 1vim /etc/profile 粘贴以下内容，保存 profile 12export MAVEN_HOME=/opt/maven/apache-maven-3.6.3export PATH=$MAVEN_HOME/bin:$PATH 刷新环境变量。 1source /etc/profile 检查一下，下图所示，成功。 1mvn -v 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/maven%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%89%8B%E5%86%8C/"},{"title":"nginx安装手册","text":"# nginx 安装手册 1. 实验环境 1.manjaro-gnome21 2.nginx-1.19.10 下载界面 2. 安装 在 /usr/local 创建 nginx 目录 123cd /usr/localmkdir nginxcd nginx 下载 nginx，解压，进入 nginx-1.19.10, 执行命令编译。生成的可执行文件在上级目录 sbin。 12345wget https://nginx.org/download/nginx-1.19.10.tar.gztar -zxvf nginx-1.19.10.tar.gzcd nginx-1.19.10/ ./configuremake &amp;&amp; make install 3.nginx 使用 启动 启动后，打开浏览器查看 127.0.0.1 成功界面 1/usr/local/nginx/sbin/nginx 停止 1/usr/local/nginx/sbin/nginx -s stop 修改配置文件后重启 1/usr/local/nginx/sbin/nginx -s reload 4. 配置 配置文件位置 1/usr/local/nginx/conf/nginx.conf 配置虚拟主机 12345678server { listen 80; server_name mysite.haha; location / { root html/mysite; index index.html index.htm; } } 修改 /etc/hosts 1127.0.0.1 mysite.haha 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/nginx%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/"},{"title":"安装node.js","text":"安装 node.js 执行命令，切换目录，创建文件夹 123cd /usr/localmkdir nodecd node 下载（https://nodejs.org/dist/v12.18.2/node-v12.18.2-linux-x64.tar.xz） 1wget https://nodejs.org/dist/v12.18.2/node-v12.18.2-linux-x64.tar.xz 解压 1tar xJvf node-v12.18.2-linux-x64.tar.xz 配置，修改～/.bash_profile 文件，加入以下内容 1vim ~/.bash_profile 12# Nodejsexport PATH=/usr/local/node/node-v12.16.3-linux-x64/bin:$PATH 更新环境变量 1source ~/.bash_profile 检验 1node -v 1npx -v 1npm version 成功了。 换源 NPM 下载速度不太友好，执行命令，安装 CNPM。淘宝有个 NPM 的镜像源 CNPM，速度可以。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 查看一下是否安装成功 1cnpm -v 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/node.js%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/"},{"title":"opencv处理图片","text":"# opencv 处理图片 1. 实验环境 1.manjaro21-gnome 2.python3.9 3.opencv-python-4.5.1.48 4.numpy-1.20.2 2. 加载、显示、保存图片 123456# 加载、显示、保存图片import cv2img = cv2.imread(&quot;1.jpeg&quot;)cv2.imwrite(&quot;save.png&quot;, img)cv2.imshow(&quot;img&quot;, img)cv2.waitKey() 2. 获取图片宽、高、通道数 12345# 获取图片宽、高、通道数import cv2img = cv2.imread(&quot;1.jpeg&quot;)print(img.shape) 输出结果 返回图片的高、宽、通道，若图像为非彩色图，则不返回通道值。 1(750, 500, 3) 3. 图像缩放 图像缩放使用 cv2.resize () 函数，第三个参数定义了缩放插值的方法。 参数 说明 INTER_NEAREST 最近邻插值法 INTER_LINEAR 双线性插值法（默认） INTER_AREA 基于局部像素的重采样 INTER_CUBIC 基于 4x4 像素邻域的 3 次插值法 INTER_LANCZOS4 基于 8x8 像素邻域的 Lanczos 插值 123456789101112# 图像缩放import cv2img = cv2.imread(&quot;1.jpeg&quot;)cv2.imshow(&quot;img&quot;, img)img1 = cv2.resize(img, (100, 600), cv2.INTER_AREA)hight, width = img.shape[0:2]img2 = cv2.resize(img, (width, hight))cv2.imshow(&quot;img1&quot;, img1)cv2.imshow('img2', img2)cv2.waitKey() 4. 图片旋转 main.py 123456789101112131415161718192021222324252627import numpy as npimport argparseimport imutilsimport cv2ap = argparse.ArgumentParser()ap.add_argument(&quot;-i&quot;, &quot;--image&quot;, required=True, help=&quot;Path to the image&quot;)args = vars(ap.parse_args())image = cv2.imread(args[&quot;image&quot;])cv2.imshow(&quot;Original&quot;, image)(h, w) = image.shape[:2]center = (w // 2, h // 2)M = cv2.getRotationMatrix2D(center, 45, 1.0)rotated = cv2.warpAffine(image, M, (w, h))cv2.imshow(&quot;Rotated by 45 Degrees&quot;, rotated)M = cv2.getRotationMatrix2D(center, -90, 1.0)rotated = cv2.warpAffine(image, M, (w, h))cv2.imshow(&quot;Rotated by -90 Degrees&quot;, rotated)rotated = imutils.rotate(image, 180)cv2.imshow(&quot;Rotated by 180 Degrees&quot;, rotated)cv2.waitKey(0) imutils.py rotate () 第一个参数为需要处理的图片，第二个为角度，第三个为旋转中心，默认为图片中心，第四个为规模，默认 1.0。 12345678910import cv2def rotate(image, angle, center=None, scale=1.0): (h, w) = image.shape[:2] if center is None: center = (w // 2, h // 2) M = cv2.getRotationMatrix2D(center, angle, scale) rotated = cv2.warpAffine(image, M, (w, h)) return rotated 5. 图像轮廓检测 1234567891011# 图片轮廓检测import cv2import numpy as npimg = cv2.imread('1.jpeg')gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #转换为灰度图像ret, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY) #转换为二值图像contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)#提取轮廓cv2.drawContours(img, contours, -1, (0, 0, 255), 2)cv2.imshow(&quot;img&quot;, img)cv2.waitKey()","link":"/2021/05/08/opencv%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87/"},{"title":"php xdebug超时问题解决","text":"实验环境 1.VS code 2.phpstudy 如何搭建配置调试环境 修改 vhost.conf 文件。 加入以下代码 12IPCConnectTimeout 3000IPCCommTimeout 3000 Virtual Host 即 Vhost ，是 linux 中的虚拟主机系统。 虚拟主机 (Virtual Host) 是在同一台机器搭建属于不同域名或者基于不同 IP 的多个网站服务的技术.。可以为运行在同一物理机器上的各个网站指配不同的 IP 和端口， 也可让多个网站拥有不同的域名。 重启 apache 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/php%20xdebug%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"title":"python opencv 操作摄像头","text":"# python opencv 操作摄像头 1. 实验环境 1.win10 2.python3.8 3.opencv-4.4.0.46 2. 源码 main.py 12345678910111213import cv2import numpy as npcap = cv2.VideoCapture(0)while 1: # get a frame ret, frame = cap.read() # show a frame cv2.imshow(&quot;capture&quot;, frame) if cv2.waitKey(1) &amp; 0xFF == ord('q'): breakcap.release()cv2.destroyAllWindows() 3. 效果 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/python%20opencv%20%E6%93%8D%E4%BD%9C%E6%91%84%E5%83%8F%E5%A4%B4/"},{"title":"python 连接sql server数据库，pymssql模块安装。","text":"# python 连接 sql server 数据库，pymssql 模块安装。 python 版本：python3.7 数据库版本：sql server 2016 连接 sql server 数据库，本菜鸟用的是 pymssql，现在我得着重说下 pymssql 的安装问题。 安装 pymssql 解决方案 往常使用滴 pip install pymssql 可能行不通（你可以去试试，反正我滴机子不行）。 资源下载 pymssql 下载 选择自己需要滴版本 下载后直接在当前目录执行 1pip install 包名 连接数据库 12345678910111213141516171819202122232425262728293031323334353637383940import pymssqlclass MSSQL: def __init__(self,host,user,pwd,db): self.host = host self.user = user self.pwd = pwd self.db = db def __GetConnect(self): if not self.db: raise(NameError,&quot;没有设置数据库信息&quot;) self.conn = pymssql.connect(host=self.host,user=self.user,password=self.pwd,database=self.db,charset=&quot;utf8&quot;) cur = self.conn.cursor() if not cur: raise(NameError,&quot;连接数据库失败&quot;) else: return cur def ExecQuery(self,sql): cur = self.__GetConnect() cur.execute(sql) resList = cur.fetchall() #查询完毕后必须关闭连接 self.conn.close() return resList def ExecNonQuery(self,sql): cur = self.__GetConnect() cur.execute(sql) self.conn.commit() self.conn.close()#根据自己的实际情况进行配置ms = MSSQL(host=&quot;127.0.0.1&quot;,user=&quot;sa&quot;,pwd=&quot;123456&quot;,db=&quot;haha&quot;)sqlStr = 'select * from jokes'list = ms.ExecQuery(sqlStr.encode('utf-8'))for i in list: print(i) 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/python%20%E8%BF%9E%E6%8E%A5sql%20server%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8Cpymssql%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E3%80%82/"},{"title":"python 初试opencv","text":"# python 初试 opencv 1. 实验环境 1.win10 2.python3.8 3.opencv-4.4.0.46 4.matplotlib-3.3.2 2. 源码 main.py 1234567891011121314151617181920212223242526#!/usr/bin/env python3# -*- coding: utf-8 -*-import cv2from pylab import *# 载入图像im = cv2.imread('1.jpg')# 颜色空间转换gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)# 显示原始图像fig = plt.figure()subplot(121)plt.gray()imshow(im)title(u'彩色图')axis('off')# 显示灰度化图像plt.subplot(122)plt.gray()imshow(gray)title(u'灰度图')axis('off')show() 效果图 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/python%E5%88%9D%E8%AF%95opencv/"},{"title":"让繁琐的工作自动化——python处理email","text":"# 让繁琐的工作自动化 ——python 处理 email 今天来谈一谈，如何用 python 处理 Email。今天的示例选用 QQ 邮箱。 以及写个利用邮件远程控制电脑下载图片。 1. 环境 1.python3.8 2.pyzmail36 v1.04 3.IMAPClient v2.1.0 4.PyEmail v0.0.1 如果 pyzmail 安装报错，请安装 pyzmail36。 2. 准备工作 需要准备个 qq 邮箱，这个很容易吧。 网页登录 qq 邮箱，点击设置，点击账户。 开启 IMAP/SMTP 服务。会生成一个授权码，把它记下来，后面需要用，这玩意相当于密码。 QQ 邮箱的一些信息，后面需要用 3. 发送邮件 导入 smtplib 1import smtplib 连接到 SMTP 服务器，smtplib.SMTP ()，第一个参数是 SMTP 服务器的域名，第二个是端口。 1smtpObj = smtplib.SMTP('smtp.qq.com', 587) 给服务器打个招呼，问个好。 注意：得到 SMTP 对象后必须调用 ehlo () 方法，向 SMTP 服务器问好。 1smtpObj.ehlo() 如果连接 SMTP 587 端口（使用 TLS 加密），需要调用 starttls ()；如果连接 SMTP 465 端口（使用 SSL），加密一设置，无需使用 starttls () 方法，请跳过这一步。 1smtpObj.starttls() 登录账号。 注意：第一个填写邮箱，第二个填生成的授权码 1smtpObj.login('xxxxxx@qq.com', 'passwd') 发送邮件。 注意：第一个参数填写登录的邮箱，第二个参数目的邮箱，第三个参数正文内容，必须以字符串’Subject: \\n’开头，作为邮件的主题行，’\\n’将正文与主题分割。 1smtpObj.sendmail('你的邮箱','目的邮箱','Subject: haha\\nhello,nie.') 与 SMTP 服务器断开。 1smtpObj.quit() 4. 获取邮件与删除邮件 导入模块 123import pyzmailimport imapclientimport imaplib 连接 IMAP 服务器，imapclient.IMAPClient（）方法第一个参数 IMAP 服务器域名，第二个参数开启 SSL 加密（大多数邮件提供商要求开启 SSL 加密） 1imapObj = imapclient.IMAPClient('imap.qq.com', ssl=True) 登录到 IMAP 服务器 注意：第一个参数你滴邮箱，第二个参数生成的授权码 1imapObj.login('xxxxxxx@qq.com', 'passwd') 选择文件夹，文件夹有很多，可以通过 list_folders () 方法获取文件夹列表（返回元组类型）。 12list1 = imapObj.list_folders() 注意：我为了输出好看，导入了 pprint 模块，调用 pprint.pprint (list1) 输出 选择文件夹，一般都有‘INBOX’(收件箱) 这个文件夹，readonly 是只读，如果你的程序不需删除邮件，建议将该参数设置为 True。 1imapObj.select_folder('INBOX', readonly=True) 搜索，search () 方法参数是字符串列表文末附录查看搜索键。该方法返回消息 ID 列表。 1MIds = imapObj.search(['ALL']) 注意：若你的搜索有大量数据，python 会抛出异常，请加入以下代码，数字代表最大字节数 12import imaplibimaplib._MAXLINE = 100000000 获取电子邮件内容，以下代码获取了 4 个 eamil 的信息。 1msgList = imapObj.fetch(MIds, ['BODY[]']) 获取电子邮件的一些信息，为了操作简洁，先导入 pyzmail 模块，创建 PyzMessage 对象，使解析电子邮件变得更方便。 12import pyzmailmsg = pyzmail.PyzMessage.factory(msgList[10][b'BODY[]']) 获取主题 1subject = msg.get_subject() 获取地址 注意：‘from’ 可替换为’to’,‘cc’,‘bcc’。cc 指抄送，bcc 指密送。 1addr = msg.get_addresses('from') 获取正文，email 可以是纯文本或 HTML 的混合，若 email 只含纯文本 PyzMwssage 对象的 html_part 设置为 None；若 email 只含 HTML，PyzMwssage 对象的 text_part 设置为 None。 1234if msg.text_part != None: text = msg.text_part.get_payload().decode(msg.text_part.charset)if msg.html_part != None: html = msg.html_part.get_payload().decode(msg.html_part.charset) 删除电子邮件 12imapObj.select_folder('INBOX', readonly=False)imapObj.delete_messages(消息ID) 与 IMAP 服务器断开 1imapObj.logout() # 实例 —— 实现通过邮件远程控制电脑下载图片。 这不就下载好了吗 注意：本例子写得太过于粗糙，有太多的问题需要修改。仅仅是为大家演示一种使用思路。 源码 123456789101112131415161718192021222324252627282930313233import imaplibimport pyzmailimport imapclientimport timeimport requestsdef download(urls): for url in urls: res = requests.get(url.replace('&amp;', '&amp;')) with open(str(time.time()) + '.jpg', 'wb') as file: file.write(res.content)def checknewpic(): imapObj = imapclient.IMAPClient('imap.qq.com', ssl=True) imapObj.login('xxxxx@qq.com', 'passwd') print(imapObj.select_folder('INBOX', readonly=True)) MIds = imapObj.search(['ALL']) msgList = imapObj.fetch(MIds, ['BODY[]']) for id in MIds: msg = pyzmail.PyzMessage.factory(msgList[id][b'BODY[]']) if msg.get_subject() == &quot;下载图片&quot;: if msg.text_part != None: urls = msg.text_part.get_payload().decode(msg.text_part.charset).split('^') download(urls)while True: checknewpic() time.sleep(60)print('---------执行完毕-----------') # 附录 ‘ALL’：返回该文件夹中的所有邮件。如果你请求一个大文件夹中的所有信息，可能会遇到 imaplib 的大小限制 ‘BEFORE/ON/SINCE date’：分别返回给定的 date 之前、当天、之后 IMAP 服务器接受的消息，日期格式必须是 01-Jul-2020 此外，虽然 “SINCE 01-Jul-2020” 将匹配 7 月 1 日当天和之后的消息，但是 “BEFORE 01-Jul-2020” 仅匹配 7 月 1 日之前的消息，不包括 7 月 1 日当天 ‘SUBJECT/BODY/TEXT string’: 分别返回 string 出现在主题、正文、主题或正文中的消息，如果 string 中有空格，就是用双引号 ‘FROM/TO/CC/BCC string’: 返回所有信息，其中 string 分别出现在 “from” 邮件地址、“to” 邮件地址、“cc”（抄送）地址、或 “bcc”（密件抄送）地址 如果 string 中有多个邮件地址，就是用空格将他们分割开，并使用双引号 ‘SEEN/UNSEEN’：分别返回包含和不包含 \\Seen 标记的所有信息。如果电子邮件已经被 fetch () 方法调用访问，或者你曾在电子邮件程序中或网络浏览器中点击过它， 就会有 \\Seen 标记，比较常用的说法是 “已读” 而不是 “已看” ‘ANSWERED/UNANSERED’: 分别返回包含和不包含 \\Answered 标记的所有信息，如果消息已答复就会有 \\Answered 标记 ‘DELERED/UNDELETED’: 分别返回包含和不包含 \\Deleted 标记的所有信息，用 delete_messages () 方法删除的邮件就会有 \\Deleted 标记，直到调用 expunge () 方法才 会永久删除 ‘DRAFT/UNDRAFT’：分别返回包含和不包含 \\Draft 标记的所有信息，草稿邮件通常保存在单独的草稿文件夹中，而不是收件箱 ‘FLAGGED/UNFLAGGED’：分别返回包含和不包含 \\Flagged 标记的所有信息，这个标记通常用来标记电子邮件的 “重要” 或 “紧急” ‘LARGER/SMALLER N’：分别返回大于或小于 N 个字节的所有信息 ‘NOT search-key’: 返回搜索键不会返回的那些信息 ‘OR search-key1 search-key2’: 返回符合第一个或者第二个搜索键的信息 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/python%E9%80%9A%E8%BF%87%E9%82%AE%E4%BB%B6%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91/"},{"title":"redis安装手册","text":"# Windows 安装 1. 实验环境 1.win10 2.redis-5.0.9(资源地址) 2. 安装验证 下载之后解压。 打开 PowerShell，切换到该目录。 执行命令，开启服务端 1.\\redis-server.exe 服务端启动成功。 再打开一个 PowerShell 窗口，切换到该目录，执行命令启动客户端 1.\\redis-cli.exe 验证一下 # ubuntu 安装 1. 实验环境 1.ubuntu16.04(安装教程) 2.gcc 5.4.0 安装：apt install gcc 3.make 4.1 安装 apt install make 4.redis-6.0.8(下载地址) 2. 安装步骤 先切换到 root 权限。 切换路径 1cd /usr/local 新建 redis 目录 1mkdir redis 下载 12cd mkdir wget http://download.redis.io/releases/redis-6.0.8.tar.gz 解压 1tar xzvf redis-6.0.8.tar.gz 编译 注意：执行 make 命令前要装好 gcc、make 12cd redis-6.0.8make 编译成功后，src 目录下将生成 redis-server、redis-cli 3. 验证 执行命令，启动服务端 1./redis-server 成功 再打开一个终端窗口，执行命令，启动客户端。 1.\\redis-cli 4. 设置远程连接 用 windows 的 redis-cli 连接虚拟机 ubuntu 的 redis。 在 Ubuntu 中 Ctrl+c 先关掉已经运行的 redis-server。 写个 redis 的配置文件 12vim /etc/redis/redis.conf#若无该/etc/redis目录，可以创建一个，当然你也可以自定义。 写入以下内容，保存。 1bind 0.0.0.0 启动 redis 服务端 12cd /usr/local/redis/redis-6.0.8/src/./redis-server /etc/redis/redis.conf 在 windows 打开 PowerShell，切换到 redis-cli 目录，执行命令。 1.\\redis-cli.exe -h 192.168.146.104 -p 6379 -p 为端口，在服务端可以自定义。 验证 今天的文章到此结束。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/redis%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/"},{"title":"shell脚本编写","text":"# shell 脚本编写 # 一些语法基础 1. 如何定义一个变量 变量名由字母、数字、下划线组成，不可以数字开头，不可使用保留关键字。 等号左右不可有空格。 1haha=&quot;jiji&quot; 使用变量：在变量名前加上 $ 1echo $haha 可以在变量外加上‘{}’ 其实加与不加都可以，加花括号可以帮助解释器更好地识别变量边界。 1echo &quot;hello world ${haha}&quot; readonly 只读变量 readonly 关键字修饰的变量不可修改。 1readonly haha=&quot;jiji&quot; 数组 定义 数组内可有不同类型数据 12345678myArray=(1 2 ‘kkk’ 4)# 或者(下标可以不连续，无限制)myArray[0]=10myArray[0]=11myArray[0]=12 读取数组内容 通过索引 12345myArray=(1 2 'jiji' 4)echo ${myArray[0]}echo ${myArray[1]}echo ${myArray[2]}echo ${myArray[3]} 输出结果 123412jiji4 获取所有元素 使用 @、* 获取。 123myArray=(1 2 'jiji' 4)echo ${myArray[@]}echo ${myArray[*]} 输出结果 121 2 jiji 41 2 jiji 4 获取数组长度 123myArray=(1 2 'jiji' 4)echo ${#myArray[@]}echo ${#myArray[*]} 输出结果 1244 2. 流程控制 if-else 1234if [ 1 == 1 ]then echo &quot;OK&quot;fi 多个 if-else 注意： 判断条件’[]' 与变量要有空格 12345678910111213a=1b=2if [ $a == $b ]then echo &quot;a等于b&quot;elif [ $a -gt $b ]then echo &quot;a大于b&quot;elif [ $a -lt $b ]then echo &quot;a小于b&quot;fi for 循环 1234for i in 1 2 3 4do echo $idone 输出结果 12341234 while 循环 123456int=1while (( $int&lt;5 ))do echo $int let &quot;int++&quot;done 输出结果 12341234 case 若无匹配项，则执行 *。 12345678910111213141516171819echo &quot;请输入一个数：&quot;read numcase $num in 1) echo &quot;1&quot; ;; 2) echo &quot;2&quot; ;; 3) echo &quot;3&quot; ;; 4) echo &quot;4&quot; ;; *) echo &quot;other&quot; ;;esac 输出结果 12345678910# 输入2请输入一个数：22# 输入 11请输入一个数：11other 无限循环 12345678910111213while :do echo &quot;hello,world&quot;donewhile truedo echo &quot;hello,world&quot;donefor((;;));doecho &quot;jiji&quot;done until int 等于 3 时停止 123456int=1until (($int==3))do echo &quot;$int&quot; let &quot;int++&quot;done break 跳出循环 continue 跳出本次循环 3. 传递参数 通常在执行脚本时，会为脚本传递一些参数 123456789101112echo &quot;$0&quot;echo &quot;$1&quot;echo &quot;$2&quot;echo &quot;$3&quot;echo &quot;$4&quot;echo &quot;传递参数的个数：$#&quot;echo &quot;当前id:$$&quot;echo &quot;$*&quot;echo &quot;$@&quot;echo &quot;最后一个id：$!&quot;echo &quot;退出状态：$?&quot; 执行命令 1./hello.sh a b c d 输出结果 1234567891011./hello.shabcd传递参数的个数：4当前id:15412a b c da b c d最后一个id：退出状态：0 参数 说明 $0 脚本名 $n 第 n 个参数 $# 传递参数的个数 $! 后台最后一个进程 id $$ 当前进程 id $? 退出状态码 $* 单字符串，所有参数 $@ 多字符串，所有参数 4. 函数定义 无参数函数定义：可以不写 function 关键字，return 后跟 0~255 作为返回值 1234567function f1(){ echo &quot;haha&quot; return 0}f1 有参数的函数 123456789function f2(){ echo &quot;$0&quot; echo &quot;$1&quot; echo &quot;$2&quot; echo &quot;$3&quot; echo &quot;$4&quot;}f2 1 2 3 4 显示结果 12345./hello.sh1234 5. 运算符 算数运算符 运算符 说明 + 加 - 减 * 乘 / 除 % 取余 = 赋值 == 比较是否相等，相等返回 true != 不相等，返回 true 关系运算符 运算符 说明 -eq 左值等于右值，返回 true -ne 左值不等于右值，返回 true -gt 左值大于右值，返回 true -lt 左值小于右值，返回 true -ge 左值大于等于右值，返回 true -le 左值小于等于右值，返回 true 字符串运算符 运算符 说明 = 字符串相等，返回 true != 字符串不相等，返回 true -z 长度为 0, 返回 true -n 长度不为 0, 返回 true $ 是否为空，不为空返回 true 逻辑运算符 运算符 说明 &amp;&amp; 逻辑 And || 逻辑 Or 布尔运算 运算符 说明 ! 非运算 -o 或运算 -a 与运算 文件测试符 参数 说明 -b file 块设备，返回 true -c file 字符设备，返回 true -d file 目录，返回 true -g file 设置 SGID 位，返回 true -k file 设置粘着位 (Sticky Bit)，返回 true -r file 可读，返回 true -w file 可写，返回 true -x file 可执行，返回 true -e file 存在，返回 true -s file 文件不为空，返回 true -p file 有名管道，返回 true -u file 设置 SUID，返回 true 注意： SUID–&gt;Set User ID SGID–&gt;Set Group ID 6. 文件包含 12345# 方法1 '.'与文件名间空格不可以忘哦. filename# 方法2 source filename 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"},{"title":"ubuntu16.04安装步骤","text":"# ubuntu16.04 安装步骤 过几天要写一个搭建博客的教程，所以准备工作还是要先搞一下。windows 与 linux 的教程应该都会出，但为了更好的性能与稳定度，我还是强烈建议用 linux 环境搭建博客。 1. 实验环境 1.ubuntu16.04 镜像 2.VMware 15.5.6 2. 安装步骤 创建新的虚拟机 点击下一步 点击下一步 选择稍后安装操作系统，点击下一步。 选择 linux ubuntu 64 位，点击下一步。 名称与位置各位大爷随意，点击下一步。 内核数自己填就好（注意总数不要超过宿主机 CPU 核心数） 内存按照自己需求配置（这个内存只是设定了该虚拟机最大可使用内存，而不是立马就占用了系统资源）。 点击下一步 点击下一步 点击下一步 点击下一步 点击浏览，选择路径（路径随意） 点击自定义硬件 选择之前下载的镜像，点击关闭，然后点击完成。 点击开启虚拟机。 语言选择 English，回车。 回车 选择 English，回车。 这是要选择国家，先选 other，回车。 选择 Asia (亚洲) 选择 China (中国) 回车 不检测键盘（用英文键盘就好），回车。 回车 等待 设置主机名（各位大爷随意） 用户名（各位大爷随意） 设置账号（各位大爷随意，登录时用） 设置密码（随意，但是一定要记住哦）要输两次 是否选择弱密码，选择 yes, 回车。 等待 你的时区是否是重庆，选择 yes。 回车就好 回车 选择 yes 回车 选择 yes 等待 设置 http 代理，没有就直接回车喽 这一步等待时间有点长，（可以点回车试试，能否跳过） 选择不自动更新系统 注意：openSSH server 一定要选择（点空格可选中）， LAMP(linux + apache + mysql + php)， Virtual Machine host 不要选，本来就是虚拟机（在虚拟机上搞虚拟肯定有问题噻）。 等待 设置 mysql root 密码（一定要记住哦）要输两次 回车 回车 装好了。输入用户名，密码登录。 注意：在 Linux 上输入密码时，是不回显的（屏幕没啥反应），如果输错了直接回车，重新输就好。 3. 连接服务器 由于虚拟机显示的命令行看起来有些恼火，so 我给各位大爷找了个工具 MobaXterm【公众号回复 shell 即可获得】（来源于互联网） 点击左上角 session。 点击 SSH 在虚拟机输入命令 ifconfig，查看 ip。我的 ip 为 192.168.190.132 填写 ip 与用户名，点击 OK。 输入密码。 sudo su 切换为 root ($ 是普通用户，# 是 root 用户) 输入命令 vim /etc/apt/sources.list (换个国内源，提升安装软件的速度)，把原来的删喽或者用 #注释了。 vim 的简单使用请自行上网查询，谢谢 12345678910111213141516deb http://mirrors.aliyun.com/ubuntu/ xenial maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial maindeb http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe 执行 apt-get update (更新一下)。 OK，今天的文章就肝到这里。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/ubuntu16.04%20%E4%BF%9D%E5%A7%86%E7%BA%A7%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"title":"ubuntu20配置ip","text":"# ubuntu20 配置 ip 1. 实验环境 1.ubuntu20 2. 配置 ip 打开终端，修改以下文件，文件名可能不一致，请灵活处理。 ens33 取决自己的实际情况。 1vim /etc/netplan/01-network-manager-all.yaml 12345678910111213# Let NetworkManager manage all devices on this systemnetwork: version: 2 #renderer: NetworkManager ethernets: ens33: addresses: [192.168.146.200/24] dhcp4: no dhcp6: no gateway4: 192.168.146.2 nameservers: addresses: [192.168.146.2,8.8.8.8] 注意：冒号后需空格，每一级缩进严格 执行命令，配置 ip 1netplan apply 查看 ip 1ip addr 测试网络连通性 1ping baidu.com 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/ubuntu20%E9%85%8D%E7%BD%AEip/"},{"title":"ubuntu下初试静态库.a 与共享库.so","text":"# ubuntu 下初试静态库.a 与共享库.so 实验目的： 欲将 a1.c，a2.c 生成静态库.a 与共享库.so 以供 test.c 使用。 阅读技术基础： 需有 gcc、makefile 的一些基础，以及熟悉 linux 基础操作。 1. 实验环境 1.ubuntu16.04(安装教程) 2.gcc-5.4.0（安装：apt install gcc ） 3.make-4.1（安装：apt install make ） 2. 测试源码 a1.c 123456789101112/************************************************************************* &gt; File Name: a1.c &gt; Author: wuhen &gt; Created Time: Tue 13 Oct 2020 12:41:27 AM CST ************************************************************************/#include&lt;stdio.h&gt;void print1(int arg){ printf(&quot;A1 print arg:%d\\n&quot;,arg);} a2.c 123456789101112/************************************************************************* &gt; File Name: a2.c &gt; Author: wuhen &gt; Created Time: Tue 13 Oct 2020 12:43:22 AM CST ************************************************************************/#include&lt;stdio.h&gt;void print2(char *arg){ printf(&quot;A2 print arg:%s\\n&quot;,arg);} a.h 123456789101112/************************************************************************* &gt; File Name: a.h &gt; Author: wuhen &gt; Created Time: Tue 13 Oct 2020 12:55:06 AM CST ************************************************************************/#ifndef A_H#define A_Hvoid print1(int);void print2(char*);#endif test.c 12345678910111213141516/************************************************************************* &gt; File Name: test.c &gt; Author: wuhen &gt; Created Time: Tue 13 Oct 2020 02:11:53 AM CST ************************************************************************/#include&lt;stdio.h&gt;#include&quot;a.h&quot;int main(){ print1(4); print2(&quot;hello,world!!!&quot;); return 0;} makefile 1234567891011121314151617181920all:a1.o a2.o test.o gcc -o all a1.o a2.o test.oa1.o:a1.c gcc -c a1.ca2.o:a2.c gcc -c a2.ctest.o:test.c a.h gcc -c a.h test.cstatic: ar crv lib.a a1.o a2.o gcc -o test1 test.c lib.acreateso: gcc -c -fpic *.c a.h gcc -shared a1.o a2.o -o lib.so gcc -o test2 test.c lib.so sudo cp lib.so /usr/lib/clean: rm a1.o a2.o test.o 3. 验证 执行命令，测试源码是否可以正常编译。 12make./all 执行命令，生成静态库 lib.a，使用 test.c 测试静态库是否可以正常使用。 1make static 执行命令，生成共享库 lib.so，并使用 test.c 进行测试。 1make createso 4. 附录 gcc 帮助信息 ar 帮助信息 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/ubuntu%E4%B8%8B%E5%88%9D%E8%AF%95%E9%9D%99%E6%80%81%E5%BA%93.a%20%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%BA%93.so/"},{"title":"ubuntu忘记用户名与密码解决方案","text":"# ubuntu 忘记用户名与密码解决方案 很多朋友经常忘记自己的用户名以及密码。为啥哩，因为他们装好了系统后就没用过，放在电脑里吃灰，等到要用的时候，发现记不得用户名及密码了。哎呀，不小心说漏了，sorry，sorry。 1. 环境 1.VMware15.5.6 2.ubuntu16.04 2. 解决方案 开启 ubuntu 虚拟机时长按 esc 键（注意：你的鼠标要聚焦到虚拟机哦，否则你的 esc 键是作用到物理机的。），选择如图选项，回车。 选择第二个选项，按 e 键编辑。 找到 linux 下一行，从最后面的 nomodeset 开始回删，删到 root 那。 然后添加 rw single init=/bin/bash，按 F10 或者 ctrl + x 瞧，我们进入系统了。 执行命令，查看下用户名。我的用户名是 wuhen3。 1cat /etc/shadow 执行命令，修改密码。 1passwd 用户名 注意：如果你的密码修改没成功，可能是你用了”1234“这种弱密码，试着在密码中添加个字母试试。 重启你的系统。登录试试。 成功。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/ubuntu%E5%BF%98%E8%AE%B0%E7%94%A8%E6%88%B7%E5%90%8D%E4%B8%8E%E5%AF%86%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"win10 初试ping","text":"# win10 初试 ping 1. 实验环境 1.win10 2.ping 2.ping 原理 PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP 网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message Protocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。 ICMP 报文类型 3. 效果 用法 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/win10%20%E5%88%9D%E8%AF%95ping/"},{"title":"win10 初试tracert","text":"# win10 初试 tracert 1. 实验环境 1.win10 2.tracert 2.tracert (Traceroute) 原理 ICMP 报文类型 Traceroute 是 ICMP 的一个应用，用来跟踪一个分组从源主机到目标主机的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。 1. 源主机向目的主机发送一连串的 IP 数据报。 2. 第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 3. 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 4. 重复以上操作… … 5. 直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。由于数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 6. 综上所述，可以得到源主机到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 3. 执行效果 打开终端 &gt;&gt; 执行命令 注意：想追踪哪个，请随意 1tracert baidu.com tracert 用法 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/win10%20%E5%88%9D%E8%AF%95tracert/"},{"title":"wireshark 分析tcp协议","text":"# wireshark 分析 tcp 协议 1. 实验环境 1.manjaro-gnome-20.1.2 2.wireshark-3.4.0 3.VMware-16.0.0 4.ubuntu16.04 (虚拟机 192.168.146.100 NAT 模式 服务端) 5.ubuntu16.04 (虚拟机 192.168.146.101 NAT 模式 客户端) 6.python3.8 2. 实验源码 server.py 运行于 192.168.146.100 12345678910import socketserver = socket.socket()server.bind(('0.0.0.0', 7777))server.listen(5)print('开始服务')while True: conn, addr = server.accept() print('a new connect from ', addr) conn.sendall(bytes('hello,world!', encoding='utf-8')) conn.close() client.py 运行于 192.168.146.101 123456import socketclient = socket.socket()client.connect(('192.168.146.100', 7777))data = client.recv(1024)client.close()print(data.decode('utf-8')) 3.wireshare 分析 三次握手，一次传输数据，四次挥手。 TCP Flags 字段 SYN 表示建立连接 FIN 表示关闭连接 ACK 表示响应 PSH 表示有 DATA 数据传输 RST 表示连接重置 TCP Seq 字段 TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。 TCP ACK 字段 ACK 携带两个信息。 期待要收到下一个数据包的编号 接收方的接收窗口的剩余容量 TCP Window 接受窗口大小，这个是可变的，用来调节数据发送速率。 IP Flags 字段 1. 长度 3 比特。 2. 该字段第一位不使用。 3. 第二位是 DF（Don’t Fragment）位，DF 位设为 1 时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发，则路由器会丢弃该上层数据包并返回一个错误信息。 4. 第三位是 MF（More Fragments）位，当路由器对一个上层数据包分段，则路由器会在除了最后一个分段的 IP 包的包头中将 MF 位设为 1。 IP Protocol 字段 8bit 的协议字段表示在 IP 上层承载的是什么协议。 0x01 表示 ICMP 协议 0x06 表示 TCP 协议 0x11 表示 UDP 协议等。 数据帧的 Type IP: 0x0800 ARP: 0x0806 源与目的 Ethernet：源 Mac 地址与目的 Mac 地址 IP：源 ip 地址与目的 ip 地址 TCP：源端口与目的端口 关于三次握手，四次挥手，请阅读这篇文章 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/wireshark%20%E5%88%86%E6%9E%90TCP%E5%8D%8F%E8%AE%AE/"},{"title":"wireshark分析UDP协议","text":"# wireshark 分析 UDP 协议 1. 实验环境 1.manjaro-gnome-20.1.2 2.wireshark-3.4.0 3.VMware-16.0.0 4.ubuntu16.04 (虚拟机 192.168.146.100 NAT 模式 服务端) 5.ubuntu16.04 (虚拟机 192.168.146.101 NAT 模式 客户端) 6.python3.8 2. 源码 功能： 客户端脚本执行 4 次，每次向服务端发送‘cao’字符串，服务端收到后向客户端发送一个字符串。 客户端源码 client.py 12345import socketclient = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)client.sendto('cao'.encode('utf-8'), ('192.168.146.100', 7777))data, addr = client.recvfrom(1024)print(&quot;from:{} data:{}&quot;.format(addr, data)) 服务端源码 server.py 123456789import socketserver = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)server.bind(('0.0.0.0', 7777))data = ['1234', 'abcd', 'jjjj', 'hello']i = 0for i in data: data, addr = server.recvfrom(1024) print(&quot;from:{} data:{}&quot;.format(addr, data)) server.sendto(i.encode('utf-8'), addr) 3. 效果 4. 分析 字段 Source Port 源端口 Destination Port 目的端口 Length 长度 UDP 的分组结构 IPv4 伪头部 当 UDP 运行在 IPv4 之上时，为了能够计算校验和，需要在 UDP 数据包前添加一个 “伪头部”。 IPv6 伪头部 部分图片来源网络，侵删。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/wireshark%E5%88%86%E6%9E%90UDP%E5%8D%8F%E8%AE%AE/"},{"title":"个人博客搭建保姆级教程1——WordPress","text":"# 个人博客搭建保姆级教程 1——WordPress 今天用 WordPress 搭建一个个人博客站。废话不说了，开搞。 一、Windows 教程 1. 环境准备 1.phpstudy (一个集成了 PHP MySQL Redis Apache Nginx 等一系列工具的软件，让服务器配置简单化。) 2.WordPress (由于是开源项目，我们直接 clone 就好。) phpstudy 安装，一路下一步就好。 Word Press 下载，如果装了 git，直接输入以下命令就好。 1git clone https://github.com/WordPress/WordPress.git 没有 git，那就打开网站（https://github.com/WordPress/WordPress） 点击冒绿光的 Code，然后点击 Download ZIP，然后解压得到源码。 2. 搭建环境 打开 phpstudy 开启 apache 注意：如果出现端口被占用，解决方案：1.netstat -ano （cmd 执行，找到占用端口进程的 PID，打开任务管理器，点击结束，之后启动 apache) 创建网站： 域名： （wordpress.myblog.com）（这玩意自己编一个，外网无法访问哦 (当然通过某些骚操作也可以)，如果要用外网访问，需要公网 ip，改天出个购买服务器与域名的文章） 端口： 默认 80，如果改了其他端口，在浏览器访问时需要加端口号。ex：http://wordpress.myblog.com：10000 根目录： 随意，我用默认的。 访问一下，成功了。（如果没有出来，刷新一下呦） 安装部署 wordpress，将下载的源码解压，移动到网站的根目录。 在浏览器打开 http://wordpress.myblog.com/wp-admin/setup-config.php (把域名换成自己的) 点击 let’s go 数据库名：WPmyblog（随意，稍后得去创建，要与后面创建数据库一致） 数据库用户名：wuhen（随意，要与后面创建数据库一致） 密码：123456（自己填，要与后面创建数据库一致） 先去安装，启动 mysql，创建对应数据库。phpstudy 集成了 mysql，直接安装就好。我这装了 mysql8.0.12。 创建数据库，要与前面表格填写的一致。 点击 submit, 看到此页面。 点击 Run…，等待。填写好信息，点击 Install 成功了！！！恭喜 点击 Log in 成功进入。在这你可以将语言更改为中文，也可以更改主题，自己去尽情地探索吧，奥里给。 二、Linux 教程 1. 环境准备 1.ubuntu16.04 (看我博客有教程) 2.LAMP 环境，装系统时默认装了。 2. 环境搭建 执行命令，切换为 root 1sudo su 执行命令，查看下 ip，我的 ip 是 192.168.190.132 1ifconfig 在浏览器访问 192.168.190.132，可以看到默认页面，根目录在 /var/www/html/，该页面是 index.html 提供的。 执行命令，切换目录 1cd /var/www/html 然后执行命令，将 WordPress clone 下来。由于某种原因，clone 有些慢。 1git clone https://github.com/WordPress/WordPress.git 访问 http://192.168.190.132/WordPress/wp-admin/install.php ，接下来的操作与 windows 相似，重点说下创建数据库。 创建数据库，执行命令，输入 MySQL 密码，然后连接。 1mysql -u root -p 执行命令，创建数据库（数据库名随意，与安装时填一致就好，数据库默认 root，密码是安装 Ubuntu16.04 时你自己设的） 1create database WPmyblog; 输入命令，查看是否成功。成功后输入 exit 退出。 1show databases; 好啦，WordPress 的教程到此为止，希望可以帮到大家。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B1%E2%80%94%E2%80%94WordPress/"},{"title":"个人博客搭建保姆级教程2——halo","text":"# 个人博客搭建保姆级教程 2——halo halo：java 开发的一个优秀的开源博客应用。需要 jdk 环境，与 tomcat。废话不说了，直接开搞。 Linux 部署 1. 环境准备 1.ubuntu16.04 2.tomcat8.5.57 3.JDK8 4.halo1.3.2 (jar 包) 2. 安装 JDK8 执行命令，输入密码，切换 root 权限。 1sudo su 执行命令，安装 JDK8，需要等待一会。 1apt-get install openjdk-8-jdk 执行命令，查看 JDK 是否安装成功。 1java -version 3. 安装 tomcat 执行以下命令，切换目录 1cd /usr/local/ 执行命令，创建 tomcat 目录 1mkdir tomcat 执行命令，切换到 tomcat 路径下。 1cd tomcat 执行命令，下载 tomcat 1wget https://us.mirrors.quenda.co/apache/tomcat/tomcat-8/v8.5.57/bin/apache-tomcat-8.5.57.tar.gz 执行命令，解压 tomcat 1tar xvzf apache-tomcat-8.5.57.tar.gz 4. 安装 halo 执行命令，切换目录到 webapps 1cd apache-tomcat-8.5.57/webapps/ 执行命令，下载 halo1.3.2 1wget https://github.com/halo-dev/halo/releases/download/v1.3.2/halo-1.3.2.jar -O halo-latest.jar 5. 运行 halo 执行命令，启动 tomcat。(只要执行 startup.sh 就好，方法随意)，成功如下图。 1bash /usr/local/tomcat/apache-tomcat-8.5.57/bin/startup.sh 执行 halo-latest.jar (一定要把路径切换到 webapps，否则会找不到 jar 包) 1java -jar halo-latest.jar 开始启动了。 启动成功，打开浏览器访 http://192.168.190.132:8090（ip 换成你自己的，服务器都连到了，应该不会不知道 IP 吧）端口是 8090，不要搞忘了。 填写信息 安装 登录 成功了，nice，释放你的激情，尽情地探索吧！！！（可以换主题啥的，自己去玩吧） windows 部署 1. 环境准备 1.tomcat-8.5.57 2.JDK8 (这个网上一搜就有了，我就不写了) 3.halo-1.3.2 2.tomcat 下载（https://mirrors.sonic.net/apache/tomcat/tomcat-8/v8.5.57/bin/apache-tomcat-8.5.57-windows-x64.zip），解压，OK。 3.halo 下载（https://github.com/halo-dev/halo/releases/download/v1.3.2/halo-1.3.2.jar），放到 tomcat 下的 webapps 目录。 4. 运行 启动 tomcat，双击 bin 目录下 startup.bat 启动 halo，（cmd 或 power shell 执行下面命令），其实双击下载的 jar 包也可以，只是看不到日志 12java -jar (jar包路径) 访问 http://127.0.0.1:8090/ 成功了。后面的操作请参考 Linux 部署教程。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B2%E2%80%94%E2%80%94halo/"},{"title":"个人博客搭建保姆级教程3——hexo","text":"# 个人博客搭建保姆级教程 3——hexo About :A fast, simple &amp; powerful blog framework, powered by Node.js.(官网介绍) 今天的目标是：白嫖！白嫖！ 白嫖服务器！！白嫖域名！！ Linux 部署 1. 环境部署 1.ubuntu16.04 2.node.js-12.18.2 3.hexo 2. 安装 node.js 执行命令，切换目录，创建文件夹 123cd /usr/localmkdir nodecd node 下载（https://nodejs.org/dist/v12.18.2/node-v12.18.2-linux-x64.tar.xz） 1wget https://nodejs.org/dist/v12.18.2/node-v12.18.2-linux-x64.tar.xz 解压 1tar xJvf node-v12.18.2-linux-x64.tar.xz 配置，修改～/.bash_profile 文件，加入以下内容 1vim ~/.bash_profile 12# Nodejsexport PATH=/usr/local/node/node-v12.16.3-linux-x64/bin:$PATH 更新环境变量 1source ~/.bash_profile 检验 1node -v 1npx -v 1npm version 成功了 3. 安装 hexo 在下述步骤中，若出现已经安装了 node 和 hexo，但是使用时出现找不到命令，请执行 source ~/.bash_profile，刷新。 注意，所有的安装过程都在 blog 文件夹里搞，如果出了什么问题，你可以直接干掉 blog 目录，重新创建一个。 创建个博客目录，切换到该目录下。 12mkdir ~/blogcd ~/blog NPM 下载速度不太友好，执行命令，安装 CNPM。淘宝有个 NPM 的镜像源 CNPM，速度可以。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 查看一下是否安装成功 1cnpm -v 安装 hexo-cli 1cnpm install hexo-cli -g 执行命令，检查一下 1hexo -v 安装 hexo-server (随着 Hexo 3 的发布，服务器已与主模块分离。要开始使用服务器，您首先必须安装 hexo-server。) 1cnpm install hexo-server --save 初始化一个博客，在建好的 blog 文件夹下。ls 查看会出现以下文件。执行 hexo init 后一定要执行 cnpm install。 12hexo initcnpm install 启动 hexo 服务 1hexo server 打开浏览器，访问 http://(服务器 ip):4000 新建一个博客，hexo 会建一个 markdown 文件（在 source/_post/ 目录下） 1hexo new &quot;博客标题&quot; 将博客内容搞进去 (为了演示，这里我将以前写的博客搞了进去) 1vim source/_post/博客标题.md 执行命令，生成静态文件。 1hexo generate 启动服务 1hexo server 成功！！！！ 4. 更换主题 如果不喜欢默认主题，可以自己换一个，网上有很多主题，下面我来演示以下。 主题官网自己上去找自己喜欢的。 我以 Tranquilpeak 举例（不同主题可能安装有所不同，自行参照教程） hexo 主题都是在 themes 目录下，配置文件在_config.yml 里，有个 theme。 1cd themes landscape 为默认主题 下载 tranquilpeak 主题 请将目录 cd 到 themes 12git clone https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak.git tranquilpeak 修改配置文件（blog 下_config.yml）theme 修改为 tranquilpeak 12vim ../_config.yml 执行命令 (一定要在 tranquilpeak 文件夹) 12cd tranquilpeakcnpm install &amp;&amp; cnpm run prod 等待 启动服务 (如果你在 tranquilpeak 目录无法启动服务， 请执行 cd 命令回到上一级目录，再执行。) 12cd ..hexo server 访问，这个主题蛮好看。 5. 白嫖 github 服务器及域名 你需要有个 GitHub 的账号，自己去搞一个。 Create a new repository，repository name 必须是 （用户名.github.io） 选不选 public 自己随意。 点击 create (下面冒绿光的) 仓库已建好。 执行命令，安装工具 hexo-deployer-git 1cnpm insatll --save hexo-deployer-git 配置 blog 目录下的_config.yml 1vim _config.yml 在# Deployment 下加入以下内容，repo 填自己仓库的地址 12345deploy: type: git repo: https://github.com/ndb000901/ndb000901.github.io.git branch: master 执行命令，把博客推送到 github 仓库。这时可能会出现以下报错，解决方案：初学 git 安装与配置 windows 版，配置一下 git， 在你 git 上面增加 SSH key 就可（生成的 key 在～/.ssh/id_rsa.pub） 1hexo d 配置好 git 后执行命令 1hexo d 刷新仓库，多了些东东 访问 https://(用户名).github.io/ OK，白嫖服务器与域名结束了。放开手脚去打造属于你的 hexo 吧。 Windows 部署 1. 安装 node.js 下载 win 版安装包 点击 next 勾选接受，next 直接 next，安装程序会帮你 Add to PATH (添加环境变量) next 打开 cmd，或者 power shell 执行命令，操作与 Linux 部署相似。请参考 Linux 部署。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94hexo/"},{"title":"个人博客搭建保姆级教程4——hugo","text":"# 个人博客搭建保姆级教程 4——hugo 官方介绍： The world’s fastest framework for building websites. Linux 部署 1. 环境 1.ubuntu16.04 2.hugo-v0.74.3 2. 安装 hugo 我们可以下载 hugo-v0.74.3 的软件包进行安装。 执行以下命令（需先切换至 root），先创建一个目录，然后下载安装包。(由于某种原因，下载速度有点慢) 1234cd ~/mkdir hugo cd hugowget https://github.com/gohugoio/hugo/releases/download/v0.74.3/hugo_0.74.3_Linux-64bit.deb 现在开始安装 1dpkg -i hugo_0.74.3_Linux-64bit.deb 执行命令，检查是否安装成功。 1hugo version 安装成功了。 3. 生成一个站点 在 hugo 目录下，执行命令。 注意：blog（执行命令后，会在当前路径新建 blog 文件夹，你也可以写个路径名） 12hugo new site blog 切换目录到 blog 文件夹 4. 搞个主题 注意：各种骚气主题安装可能略有不同，仔细看安装文档。 主题官网 很多好看的主题，自己选一个哦。 我用 cupper 主题 举个例子。 执行命令，将目录切换至 blog 目录下的 themes，下载主题。 12cd themesgit clone https://github.com/zwbetz-gh/cupper-hugo-theme.git cupper 回到 blog 目录，执行命令，启动服务。8080 是端口，你可以自己写个别的。ip 写你自己的。 端口范围：0~65535，建议大于 1024。如果端口被占用，换个别的。 123cd ~/hugo/bloghugo server -D --bind 192.168.190.129 -p 8080 --baseURL=http://192.168.190.129:8080 --buildDrafts --theme=cupper 访问 http://192.168.190.129:8080/（用你自己的 IP，主题找你自己喜欢的，我只是随便做个演示。） 想换站点标题，请修改 blog 下的 config.toml 文件。修改 title 后面的字符串。 1vim config.toml 5. 如何发文章 hugo 支持 markdown 语法。 执行命令，新建一篇文章。（我用以前的文章做个演示） 1hugo new post/Linux如何使用U盘等外接储存设备.md 新建成功，文件在 content 目录下，现在我们来编辑一下。 1vim content/post/Linux如何使用U盘等外接储存设备.md 保存文件，然后开启服务。 1hugo server -D --bind 192.168.190.129 -p 8080 --baseURL=http://192.168.190.129:8080 --buildDrafts --theme=cupper 访问 http://192.168.190.129:8080/post/ 注意：一定要加 post 目录哦 访问第一篇文章。 6. 部署到 github 需要配置好 git 看这个教程 你需要有个 GitHub 的账号，自己去搞一个。 Create a new repository，repository name 必须是 （用户名.github.io） 选不选 public 自己随意。 点击 create (下面冒绿光的) 仓库已建好。 执行命令，生成静态文件。在 public 文件夹下。 1hugo --theme=cupper --baseUrl=&quot;https://ndb000901.github.io/&quot; --buildDrafts 切换目录到 public 下，初始化 git 仓库，将站点部署到仓库。 12345git initgit add .git commit -m &quot;第一次提交&quot;git remote add origin git@github.com:ndb000901/ndb000901.github.io.git #将用户名换成你自己的git push -u origin master 访问 https://ndb000901.github.io/post 成功部署。 Windows 部署 1. 下载 hugo hugo 下载，解压。 打开文件管理 右击此电脑，点击属性 点击高级系统设置 点击环境变量 选择 PATH，点击编辑。没有 PATH，自己新建一个。 新建一个，加入解压出 hugo.exe 的路径。然后保存。 打开 cmd，或者 powershell。验证环境变量是否添加成功。 1hugo version 接下来的工作与 linux 部署类似。请参考 Linux 部署。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B4%E2%80%94%E2%80%94hugo/"},{"title":"初学git安装与配置windows版","text":"# windows 版 今晚搞了 git，遇到了一些问题，赶紧来记录一哈。 1.Git 下载与安装 注意：安装是图形化安装，跟个指示就可。 有这个 Git bash 就可。 2. 开始配置 a. 打开 Git bash &gt;b. 配置信息 1.git config --global user.name “Your Name” 2.git config --global user.email “email@example.com” 注意： Your Name 是你要设置的名字，email@example.com 是你要设置的邮箱。 git config 命令的–global 参数，用了这个参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和 Email 地址。 3.ssh-keygen -t rsa -C “email@example.com” 注意： email@example.com 是你要设置的邮箱。 接着显示： Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa) 4. 执行 3 后会显示一个路径，找到下图 id_rsa.pub 文件，记事本打开，全部复制，打开你的 github。 如果没有那个文件（请打开显示隐藏文件，不会请百度） 点击右上角头像 点击 SSHa and GPG keys 点击 new DSSH key，将复制内容粘贴进去保存。 5.ssh -T git@github.com（Git bash 试试） 跳出下面信息，OK 了。 3. 建本地库 若看不懂以下命令，请看下 linux 基础命令 a.mkdir hello（新建目录） b.cd hello c.git init（把这个目录变成 Git 可以管理的仓库） d. 在 hello 目录下创建一个文件 readme.txt (文件名随意，创建方法随意，测试用)。 e.git add readme.txt（把文件添加到仓库） f.git commit -m “wrote a readme file”（把文件提交到仓库，引号里面是提交说明） 4. 建远程仓库 a. 直接 new 一个 点击 create. b.git remote add origin git@github.com: 用户名 / 仓库名.git 注意：远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库。 c.git push -u origin master 由于远程库是空的，我们第一次推送 master 分支时，加上了 - u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。 d. 刷新 github hello 仓库发现和你本地库一致，OK。 e. 从现在起，只要本地作了提交，就可以通过命令：git push origin master 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E5%88%9D%E5%AD%A6git%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEwindows%E7%89%88/"},{"title":"初试Cisco Packet Tracer--1——集线器","text":"# 初试 Cisco Packet Tracer–1—— 集线器 1. 实验环境 1.win10 2.Cisco Packet Tracer-7.3.1.0362(下载链接) 2. 搭建网络 实验前必读： 集线器相比于交换机更为简单，它可以被视作有多个端口的中继器，从一个端口接受比特位（或符号），再从其他端口提交。它对物理层数据包有所感知，可以检测到其开始、挂起及冲突。在检测到冲突时会发送拥塞信号以传播这一事件。集线器不能对经过它的网络流量做更进一步地检查与管理：任何进入的数据包都会被广播到其他端口。集线器 / 中继器无法储存数据 —— 数据包必须在接收时被发送，一旦发生冲突，就会丢包（发送端应当能够侦测到，并重新发送）。基于此，集线器只能以半双工模式工作。因此，由于冲突域更广，相比于使用更复杂的网络设备，使用集线器的数据网络更容易出现数据包冲突。 集线器（hub）属于纯硬件网络底层设备，基本上不具有类似于交换机的 &quot;智能记忆&quot; 能力和 &quot;学习&quot; 能力。它也不具备交换机所具有的 MAC 地址表，所以它发送数据时都是没有针对性的，而是采用广播方式发送。也就是说当它要向某节点发送数据时，不是直接把数据发送到目的节点，而是把数据包发送到与集线器相连的所有节点，如图所示，简单明了。 搭建网络的元件都在如下工具栏里。 将所需元件添加至工作空间后，点击闪电符号，开始连接线路。 闪电符号可以帮你自动选择线的种类，当然你也可自己选择 左键点击 PC0&gt;&gt;Desktop&gt;&gt;IP Configuration，配置 ip。 PC0 IP PC1 IP PC2 IP 根据下图构建 ICMP 数据报，使其从 PC0 发到 PC1，但是由于是新建的机子，PC0 ARP 高速缓存为空，所以先构建 ARP 广播帧。点击 5 逐步观察数据报流向。你可以查看右侧 Event List 里的详情，查看数据如何封装。 点击右侧 Event List 面板中的 Reset Simulation 后，重新开始 ICMP 数据包，现在 PC0 ARP 高速缓存已有 PC1 的 mac 地址，所以不需构建 ARP 广播。 3. 感受碰撞 构建这样一种情形。 PC0 给 PC1 发送 PC3 给 PC5 发送 如上图，线路会出现碰撞，导致发送失败。 如何解决这个问题呢？下期分析 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E5%88%9D%E8%AF%95Cisco%20Packet%20Tracer--1%E2%80%94%E2%80%94%E9%9B%86%E7%BA%BF%E5%99%A8/"},{"title":"初试Cisco Packet Tracer–2——交换机","text":"# 初试 Cisco Packet Tracer–2—— 交换机 1. 实验环境 1.win10 2.Cisco Packet Tracer-7.3.1.0362(下载链接) 2. 搭建网络 因为交换机有带宽很高的内部交换矩阵和背部总线，并且这个背部总线上挂接了所有的端口，通过内部交换矩阵，就能够把数据包直接而迅速地传送到目的节点而非所有节点， 这样就不会浪费网络资源，从而产生非常高的效率。同时在此过程中，数据传输的安全程度非常高，更是受到使用者的欢迎和普遍好评。 和集线器每个端口共享同样带宽不同的是，交换机的数据带宽具有独享性。在这样的前提下，在同一个时间段内，交换机就可以将数据传输到多个节点之间，并且每个节点都可 以当做独立网段而独自享有固定的部分带宽，这样就没有和其他设备进行竞争实用的必要。 网络结构 PC0–&gt;192.168.100.1 PC1–&gt;192.168.100.2 PC2–&gt;192.168.100.3 PC0 向 PC1 发送 ICMP 数据包。 由于设备是新的，PC0 ARP 高速缓存空，发送 ICMP 数据报时先广播，得到 PC1 的 mac 地址后，才发送 ICMP 数据报。当你再次发送时，这时交换机与集线器的区别就可以体现出来了。交换机会自学习，会记住每个接口对应的 mac 地址，这样它不会像集线器那样每一个数据包都广播出去，大大提高了效率。详细的过程，请在仿真时观看。 3. 上次的问题解决方案 两个用集线器相连接的网络，之间用交换机相连，交换机经过自学习后，可以有效解决碰撞问题，具体细节请仿真观察。 同时使 PC0 发送 ICMP 数据包给 PC1；PC3 发送 ICMP 数据包给 PC5。第一次发送可能会发生碰撞（交换机是新的），第二次发送时不会碰撞（交换机自学习）。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E5%88%9D%E8%AF%95Cisco%20Packet%20Tracer%E2%80%932%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"title":"初试Cisco Packet Tracer–3——访问Web服务器","text":"# 初试 Cisco Packet Tracer–3—— 访问 Web 服务器 1. 实验环境 1.win10 2.Cisco Packet Tracer-7.3.1.0362(下载链接) 2. 环境搭建 网络拓扑 PC0–&gt;192.168.100.1 Server0–&gt;192.168.100.2 点击 PC0&gt;&gt;Web Browser 输入 192.168.100.2，开始仿真 点击下一步，逐步观察 最后点开右侧 Event List 查看详细过程 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E5%88%9D%E8%AF%95Cisco%20Packet%20Tracer%E2%80%933%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AEWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"初试Cisco Packet Tracer–4——部署DHCP、DNS、Web服务器","text":"# 初试 Cisco Packet Tracer–4—— 部署 DHCP、DNS、Web 服务器 1. 实验环境 1.win10 2.Cisco Packet Tracer-7.3.1.0362(下载链接) 2. 环境搭建 网络拓扑图 3 台 server 设备、3 台 PC 设备、1 台交换机 2960 DHCP 服务器配置，开启 DHCP。 ip 配置为静态 Web 服务器配置，开启 HTTP IP 配置为静态 ip DNS 服务器配置，开启 DNS ip 配置，其实网关这玩意不填也可以，反正在同一个子网。 3.DHCP 服务仿真 步骤： 点击下图 simulation，点击 &gt;&gt;PC0&gt;&gt;Desktop&gt;&gt;IP Configuration 点击 DHCP，此时 PC0 开始向 DHCP 服务器获取 ip。具体过程请点击下一步观测。 4.Web 访问仿真 依旧使用 PC0&gt;&gt; 打开 Web Browser 访问 Web 服务器 192.168.100.2，详细过程请观察仿真。 5.DNS 服务 依旧使用 PC0&gt;&gt; 打开 Web Browser 这次访问 www.baidu.com，观测请求 DNS 服务器的过程。 由于我们的 DNS 服务器没有数据，无法解析域名对应的 ip，最后提示 Host Name Unresolved 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E5%88%9D%E8%AF%95Cisco%20Packet%20Tracer%E2%80%934%E2%80%94%E2%80%94%E9%83%A8%E7%BD%B2DHCP%E3%80%81DNS%E3%80%81Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"初试Cisco Packet Tracer–5——路由器连接两个子网","text":"# 初试 Cisco Packet Tracer–5—— 路由器连接两个子网 1. 实验环境 1.win10 2.Cisco Packet Tracer-7.3.1.0362(下载链接) 2. 环境搭建 网络拓扑图 IP 配置 PC0–&gt;192.168.100.1 PC1–&gt;192.168.100.2 打开 PC0 Command Prompt 测试连通性，如下图所示，网络连通。 1ping 192.168.100.2 接下来，我们将个人 PC1 的 ip 设置为 192.168.101.1，子网掩码 (Subnet Mask) 255.255.255.0，这时 PC0 与 PC1 不在同一网络。 如何得知主机所在的网络号：ip 地址与子网掩码按位与，得到的结果为网络号，网络号不同的主机位于不同的网络中。 这时我们用 PC0 去 ping PC1 , 无法 ping 通。因为不在同一子网，需要路由器。 1ping 192.168.101.1 添加路由器后的网络拓扑图 大家可以点击 Options&gt;&gt;Preferences 把 Always Show Port… 勾选上，效果如下图 现在线路有红色的标志，是因为没有开启路由器相应接口。点击路由器 &gt;&gt;Config 配置 配置 Gig0/0/0 接口 123勾选Port Status 后面的on配置ip 192.168.100.254配置子网掩码 255.255.255.0 配置 Gig0/0/1 接口 123勾选Port Status 后面的on配置ip 192.168.101.254配置子网掩码 255.255.255.0 开始用 PC0 去 ping PC1，发现依旧 ping 不通。因为 PC0 与 PC1 不在同一网络，PC0 要连通 PC1 需要设置网关。 1ping 192.168.101.1 现在我们开始为 PC0，PC1 配置网关 (Gateway) PC0 ping PC1，现在可以 ping 通了，但是你会发现第一次 ping 丢了一个数据包，这是因为设备都是新的，在 PC0 发送 ICMP (ping 是 ICMP echo 的应用) 之前发起了 ARP 广播，导致超时。 PC1 ping PC0 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E5%88%9D%E8%AF%95Cisco%20Packet%20Tracer%E2%80%935%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E5%99%A8%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E5%AD%90%E7%BD%91/"},{"title":"处理Ubuntu python多版本管理问题","text":"# 处理 Ubuntu python 多版本管理问题 前几天在 Ubuntu 遇到了 Python 多版本问题，今天心血来潮，想把自己摸索到的方法记录下来。 1234系统安装的Python版本python2.7python3.6python3.7 1234系统pip版本pippip2pip3 当我用 python3.7 开发程序时，需要用 pip3 安装依赖包，pip3 总是把包给我搞到 python3.6 下，让我很不爽。 下面介绍一种解决方法： 1. 找到 python,pip 所在目录。 123我的系统在/usr/bin/路径下。命令 cd /usr/bin查看一下 ls -l 冒绿光的是可以执行滴文件 冒蓝光的是链接文件 (您可以理解为类似 Windows 的快捷方式) 要想更改 pip3 install 的安装位置，可以这么操作。 12编辑pip3(这玩意就是个Python脚本)vim pip3 将第一行的 python 版本修改你想要的版本，然后保存，问题就解决喽。 另一个问题就是你在 shell 命令使用 Python 时，Python 版本问题。 比如你的系统安装了 Python2.7，Python3.6，Python3.7 这时你在命令窗口 输入 python2 -----&gt; 使用 Python2.7 版本 输入 python3 -----&gt; 使用 Python3.6 版本 如何使用 Python3.7 呢 1234cd /usr/bin找到python3.7目录（就是找到前面说的冒绿光的python3.7目录）添加软链接ln -s /usr/bin/python3.7(找到python3.7的路径) /usr/bin/python3.7 (软链接名字您老随意) 为啥软连接的路径在 /usr/bin 下呢 1$PATH 这些目录应该都可以，你可以试试。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E5%A4%84%E7%90%86Ubuntu%20python%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98/"},{"title":"让繁琐的工作自动化——python 处理Excle文件","text":"# 让繁琐的工作自动化 ——python 处理 Excle 文件 今天收到一个省市县区的 Excle 表格，想着整理一下数据，将信息整理为层级关系（省–&gt; 市–&gt;(县 / 区)）存到字典里，以备不时之需。 打开一看，MD，3 千行数据，这 TM 要搞到神马时候。 叮铃铃～～～～叮铃铃～～～～，人生苦短，我用 python。开搞！！！ # openpyxl 的基础使用 环境 1.pycharm2020.1 2.python3.8 3.openpyxl 2.1.4 openpyxl 已经更新到 3 点多了，我这里演示的是 openpyxl 2.1.4。 导入 openpyxl 模块 1import openpyxl 读取操作 打开要处理的文件，该函数需要传入一个文件路径。wb 是一个 Workbook 对象。 1wb = openpyxl.load_workbook(&quot;省市县区.xlsx&quot;) Excel 文档有多个 sheet 组成。 获得 Excel 文档所有 sheet。 1sheetList = wb.get_sheet_names() 根据 sheet 名字获取对应表。表由一个 Worksheet 对象表示，sheet 就是一个 Worksheet 对象。 1sheet = wb.get_sheet_by_name(&quot;sheet名字&quot;) 取得 sheet 表格中的值 数值定位：row 是行号，column 是列号。 字符定位：Excle 用字母表示列，数字表示行。 12x = sheet.cell(row=1, column=1).value #第一种表示y = sheet['A1'].value #第二种表示 列字母和数字之间的转换。 12openpyxl.cell.column_index_from_string() #字母----&gt;数字openpyxl.cell.column_letter() #数字----&gt;字母 获取 sheet 有多大。 12sheet.get_highest_row() #返回行数sheet.get_highest_column() #返回列数 遍历 sheet 1234for i in range(1, sheet.get_highest_row() + 1): for j in range(1, sheet.get_highest_column() + 1): print(str(sheet1.cell(row=i, column=j).value) + &quot; &quot;, end=&quot;&quot;) print() 写入操作 创建新的 Workbook 对象。 1wb = openpyxl.Workbook() 保存文件。(传入文件名) 1wb.save(&quot;haha.xlsx&quot;) 创建 sheet，index 表示 sheet 的次序，title 表示 sheet 的名字。 1wb.create_sheet(index=0,title='haha') 删除 sheet，需要传入 Worksheet 对象，如果知道 sheet 的名字，就可使用以下代码删除 1wb.remove_sheet(wb.get_sheet_by_name(&quot;sheet名字&quot;)) 写入数据 12sheet.cell(row=1, column=1) = x #第一种表示sheet['A1'] = y #第二种表示 # 处理表格的源码 原表格公众号回复【省市】获得 12345678910111213141516171819import pprintimport openpyxlwb = openpyxl.load_workbook(&quot;省市县区.xlsx&quot;)sheet = wb.get_sheet_by_name(&quot;省市县区&quot;)data = {}for i in range(2, sheet.get_highest_row() + 1): province = sheet.cell(row=i, column=1).value city = sheet.cell(row=i, column=2).value county = sheet.cell(row=i, column=3).value data.setdefault(province, {}) data[province].setdefault(city, []) if data[province][city].count(county) == 0: data[province][city].append(county)print(&quot;数据整理完毕，开始写入文件&quot;)with open(&quot;cityInfo.py&quot;, &quot;w&quot;, encoding='utf-8') as file: file.write(&quot;cityInfo = &quot; + pprint.pformat(data))print(&quot;文件写入完毕&quot;) 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E8%AE%A9%E7%B9%81%E7%90%90%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96%E2%80%94%E2%80%94python%20%E5%A4%84%E7%90%86Excle%E6%96%87%E4%BB%B6/"},{"title":"让繁琐的工作自动化——python处理CSV文件","text":"# 让繁琐的工作自动化 ——python 处理 CSV 文件 CSV：CSV 文件是一种简化的电子表格，不同于 Excle (二进制文件)，CSV 是纯文本文件。 1. 环境 1.python3.8 2.pycharm2020.1 2. 读取 本期实例数据 12345haha,18,10.0jiji,16,12.1lala,17,11.9papa,11,13.3 首先导入 csv 模块，不需要安装，python 自带的。 1import csv 要想用 csv 模块读取 csv 文件数据，需要先创建一个 Reader 对象，Reader 可以遍历文件的每一行。 注意：Reader 对象只能循环遍历一次，如果想要再次遍历，需要重新创建。 1234file = open(&quot;haha.csv&quot;)reader = csv.reader(file)data = list(reader)print(data) 以下为在交互式界面操作。 使用 Reader 对象遍历数据，Reader.line_num 标志当前遍历到第几行。 12345import csvfile = open(&quot;haha.csv&quot;)reader = csv.reader(file)for row in reader: print((&quot;第{}行 &quot; + str(row)).format(reader.line_num)) 3. 写入 将数据写入到 CSV 文件，需要用到 Writer 对象。 与读取一样，先导入 csv 模块，然后打开文件。 encoding 是编码；newline 等于空字符，若不设置，在 Windows 系统上，行距会变成下图所示。 12import csvfile = open('haha.csv', 'w', encoding='utf-8', newline='') 创建 Writer 对象，csv.writer () 有两个参数需要注意。 delimiter： 单元格分隔符，默认为逗号，可以修改为其他。 lineterminator：行终止符，默认为换行符，可以自行修改。 1writer = csv.writer(file) 写入数据，使用 writer.writerow（），该函数接受一个列表，返回写入该行的字符数（包括换行符） 1234writer.writerow(['haha', '18', '10.0'])writer.writerow(['jiji', '16', '12.1'])writer.writerow(['lala', '17', '11.9'])writer.writerow(['papa', '11', '13.3']) 写入完整源码 12345678import csvfile = open('haha.csv', 'w', encoding='utf-8')writer = csv.writer(file)writer.writerow(['haha', '18', '10.0'])writer.writerow(['jiji', '16', '12.1'])writer.writerow(['lala', '17', '11.9'])writer.writerow(['papa', '11', '13.3'])file.close() # 原创不易，点个赞再走吧。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E8%AE%A9%E7%B9%81%E7%90%90%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96%E2%80%94%E2%80%94python%E5%A4%84%E7%90%86CSV%E6%96%87%E4%BB%B6/"},{"title":"让繁琐的工作自动化——python处理JSON文件","text":"# 让繁琐的工作自动化 ——python 处理 JSON 文件 不得不说，python 真 TMD 香。由于 python 解析 json 过于简洁，我只好写个实例了，不然文章太短。 1. 环境 1.python3.8 2.pycharm 2020.1 2. 读取 JSON 数据 当然首先要导入 json 模块 1import json 读取 json 数据 12345data = '{&quot;a&quot;:123,&quot;b&quot;:&quot;lala&quot;}'result = json.loads(data)print(result)print(result['a']) 交互式界面 3. 写出 JSON 数据 导入模块 1import json 输出 json 数据，将 python 字典转为 json 数据 123data = {'a':1234,'b':'lalala'}result = json.dumps(data)print(result) # 实例，抓取中国地震台网数据，解析 JSON 数据包。 完整源码 123456789101112import jsonimport requestsres = requests.get('http://news.ceic.ac.cn/ajax/google')text = res.text.encode('utf-8')result = json.loads(text)print('%-20s' % 'id' '%-20s' % '地点' '%-20s' % '震级' '%-20s' % '经度' '%-20s' % '纬度' '%-20s' % '深度' '%-20s' % '时间')for e in result: print('%-20s' % str(e['id']), '%-20s' % str(e['LOCATION_C']), '%-20s' % str(e['M']), '%-20s' % str(e['EPI_LON']), '%-20s' % str(e['EPI_LAT']), '%-20s' % str(e['EPI_DEPTH']), '%-20s' % str(e['O_TIME'])) 排版有点烂，各位大爷多多包涵。 作者 info 作者：DebugWuhen 原创公众号：『DebugWuhen』，专注于记录有趣的编程技术和有益的程序人生，期待你的关注。 转载说明：务必注明来源（注明：来源于公众号：DebugWuhen， 作者：DebugWuhen）","link":"/2021/05/08/%E8%AE%A9%E7%B9%81%E7%90%90%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96%E2%80%94%E2%80%94python%E5%A4%84%E7%90%86JSON%E6%96%87%E4%BB%B6/"},{"title":"web作业","text":"# 淘宝优惠券查询 # 项目需求 接入淘宝联盟 - 阿里妈妈 API，开发淘宝商品优惠券查询、分发 Web 站点。通过替商家推广商品，赚取佣金。将 web 站点与 QQ 机器人结合，通过社交软件推广 # 开发环境 1.MDB-Pro-4.12 2.php-7.2 3.nginx-1.14.0 # 站点 域名被封，由于阿里妈妈身份令牌需要域名备案，不晓得令牌何时失效 http://139.186.201.25/ 首页 由于本项目当时结合 QQ 机器人使用，主要使用搜索页面，并没有开发首页。 搜索结果 商品详情 QQ 机器人 由于鹅厂严打，之前开发的 QQ 机器人由于服务商跑路，无法使用 # 项目需要改进的部分 1. 不适合高并发场景 2. 没有接入数据库将一些数据持久化 (API 调用次数每天 10w+，站点流量较小，API 调用次数冗余) 3. 接入 redis，加快站点访问速度 4.CDN 加速 # 项目部署 # 环境 1.ubuntu18.04 2.nginx-1.14.0 3.php-fpm7.2 # 安装 12345678910111213141516sudo apt update# 安装nginxsudo apt install nginx# 安装php-fpmsudo apt-get install php7.2-fpm#配置php-fpmsudo vi /etc/php/7.2/fpm/php.ini将;cgi.fix_pathinfo=1改成cgi.fix_pathinfo=0(还要去掉分号) 配置 nginx sudo vim /etc/nginx/sites-available/default 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051server {listen 80 default_server;listen [::]:80 default_server;# SSL configuration## listen 443 ssl default_server;# listen [::]:443 ssl default_server;## Note: You should disable gzip for SSL traffic.# See: https://bugs.debian.org/773332## Read up on ssl_ciphers to ensure a secure configuration.# See: https://bugs.debian.org/765782## Self signed certs generated by the ssl-cert package# Don't use them in a production server!## include snippets/snakeoil.conf;root /var/www/html;# Add index.php to the list if you are using PHPindex index.html index.htm index.nginx-debian.html;server_name _;location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404;}# pass PHP scripts to FastCGI server##location ~ \\.php$ {#include snippets/fastcgi-php.conf;## # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;# # With php-cgi (or other tcp sockets):# fastcgi_pass 127.0.0.1:9000;#}# deny access to .htaccess files, if Apache's document root# concurs with nginx's one##location ~ /\\.ht {# deny all;#}} 修改 12345678location ~ \\.php$ { include snippets/fastcgi-php.conf;## # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.2-fpm.sock;# # With php-cgi (or other tcp sockets):# fastcgi_pass 127.0.0.1:9000;} 安装依赖 12sudo apt-get install php7.2-xmlsudo apt-get install php-curl 重启 12sudo service nginx restartsudo service php7.2-fpm restart","link":"/2021/06/02/taoWeb/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"软件安装","slug":"软件安装","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"web","slug":"web","link":"/tags/web/"}],"categories":[]}